{
    "total_words": 211947,
    "total_links": 87,
    "filtered_total_words": null,
    "links": {
        "https://nodejs.org/api/events.html": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0 documentation\n Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nPassing arguments and this to listeners\n#\n\nThe eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', function(a, b) {\n  console.log(a, b, this, this === myEmitter);\n  // Prints:\n  //   a b MyEmitter {\n  //     _events: [Object: null prototype] { event: [Function (anonymous)] },\n  //     _eventsCount: 1,\n  //     _maxListeners: undefined,\n  //     [Symbol(shapeMode)]: false,\n  //     [Symbol(kCapture)]: false\n  //   } true\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\n\nIt is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  console.log(a, b, this);\n  // Prints: a b {}\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nAsynchronous vs. synchronous\n#\n\nThe EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  setImmediate(() => {\n    console.log('this happens asynchronously');\n  });\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY",
            "word_count": 741
        },
        "https://nodejs.org/api/events.html#eventtargetremoveeventlistenertype-listener-options": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventtarget": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#emittersetmaxlistenersn": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY",
            "word_count": 2773
        },
        "https://nodejs.org/api/events.html#eventiniteventtype-bubbles-cancelable": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#capture-rejections-of-promises": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2669
        },
        "https://nodejs.org/api/events.html#event-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2759
        },
        "https://nodejs.org/api/events.html#eventpreventdefault": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2759
        },
        "https://nodejs.org/api/events.html#nodeeventtargetofftype-listener-options": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#awaiting-multiple-events-emitted-on-processnexttick": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\nevents.captureRejections\n#\nHistory\n\nValue: <boolean>\n\nChange the default captureRejections option on all new EventEmitter objects.",
            "word_count": 1228
        },
        "https://nodejs.org/api/events.html#new-eventseventemitterasyncresourceoptions": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\nevents.captureRejections\n#\nHistory\n\nValue: <boolean>\n\nChange the default captureRejections option on all new EventEmitter objects.\n\nevents.captureRejectionSymbol\n#\nHistory\n\nValue: Symbol.for('nodejs.rejection')\n\nSee how to write a custom rejection handler.\n\nevents.listenerCount(emitter, eventName)\n#\nAdded in: v0.9.12Deprecated since: v3.2.0\n\nStability: 0 - Deprecated: Use emitter.listenerCount() instead.\n\nemitter <EventEmitter> The emitter to query\neventName <string> | <symbol> The event name\n\nA class method that returns the number of listeners for the given eventName registered on the given emitter.\n\nconst { EventEmitter, listenerCount } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.",
            "word_count": 2235
        },
        "https://nodejs.org/api/events.html#eventtargetaddeventlistenertype-listener-options": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 3160
        },
        "https://nodejs.org/api/events.html#emitterrawlistenerseventname": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY",
            "word_count": 3265
        },
        "https://nodejs.org/api/events.html#eventemitterasyncresourceasyncresource": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.",
            "word_count": 3621
        },
        "https://nodejs.org/api/events.html#nodeeventtarget-vs-eventemitter": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 3160
        },
        "https://nodejs.org/api/events.html#eventstopimmediatepropagation": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2759
        },
        "https://nodejs.org/api/events.html#": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0 documentation\n Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2239
        },
        "https://nodejs.org/api/events.html#emitteraddlistenereventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2669
        },
        "https://nodejs.org/api/events.html#emitterremovelistenereventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2669
        },
        "https://nodejs.org/api/events.html#eventtargetdispatcheventevent": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventssetmaxlistenersn-eventtargets": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2308
        },
        "https://nodejs.org/api/events.html#emitterlistenercounteventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258
        },
        "https://nodejs.org/api/events.html#emittereventnames": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258
        },
        "https://nodejs.org/api/events.html#emitteremiteventname-args": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2464
        },
        "https://nodejs.org/api/events.html#event-newlistener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2669
        },
        "https://nodejs.org/api/events.html#emitterremovealllistenerseventname": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2792
        },
        "https://nodejs.org/api/events.html#nodeeventtargetsetmaxlistenersn": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventcomposedpath": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventcancelbubble": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventtarget-error-handling": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2594
        },
        "https://nodejs.org/api/events.html#eventsonceemitter-name-options": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\nevents.captureRejections\n#\nHistory\n\nValue: <boolean>\n\nChange the default captureRejections option on all new EventEmitter objects.\n\nevents.captureRejectionSymbol\n#\nHistory\n\nValue: Symbol.for('nodejs.rejection')\n\nSee how to write a custom rejection handler.\n\nevents.listenerCount(emitter, eventName)\n#\nAdded in: v0.9.12Deprecated since: v3.2.0\n\nStability: 0 - Deprecated: Use emitter.listenerCount() instead.\n\nemitter <EventEmitter> The emitter to query\neventName <string> | <symbol> The event name\n\nA class method that returns the number of listeners for the given eventName registered on the given emitter.\n\nconst { EventEmitter, listenerCount } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY",
            "word_count": 3696
        },
        "https://nodejs.org/api/events.html#eventdetail": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventscapturerejectionsymbol": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.captureRejectionSymbol\n#\nHistory\n\nValue: Symbol.for('nodejs.rejection')\n\nSee how to write a custom rejection handler.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2251
        },
        "https://nodejs.org/api/events.html#class-nodeeventtarget": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventreturnvalue": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#class-eventtarget": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#nodeeventtargeteventnames": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#eventslistenercountemitter-eventname": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.listenerCount(emitter, eventName)\n#\nAdded in: v0.9.12Deprecated since: v3.2.0\n\nStability: 0 - Deprecated: Use emitter.listenerCount() instead.\n\nemitter <EventEmitter> The emitter to query\neventName <string> | <symbol> The event name\n\nA class method that returns the number of listeners for the given eventName registered on the given emitter.\n\nconst { EventEmitter, listenerCount } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2310
        },
        "https://nodejs.org/api/events.html#eventcomposed": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#events": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#error-events": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nPassing arguments and this to listeners\n#\n\nThe eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', function(a, b) {\n  console.log(a, b, this, this === myEmitter);\n  // Prints:\n  //   a b MyEmitter {\n  //     _events: [Object: null prototype] { event: [Function (anonymous)] },\n  //     _eventsCount: 1,\n  //     _maxListeners: undefined,\n  //     [Symbol(shapeMode)]: false,\n  //     [Symbol(kCapture)]: false\n  //   } true\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\n\nIt is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  console.log(a, b, this);\n  // Prints: a b {}\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nAsynchronous vs. synchronous\n#\n\nThe EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  setImmediate(() => {\n    console.log('this happens asynchronously');\n  });\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.",
            "word_count": 1274
        },
        "https://nodejs.org/api/events.html#eventistrusted": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#asynchronous-vs-synchronous": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nPassing arguments and this to listeners\n#\n\nThe eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', function(a, b) {\n  console.log(a, b, this, this === myEmitter);\n  // Prints:\n  //   a b MyEmitter {\n  //     _events: [Object: null prototype] { event: [Function (anonymous)] },\n  //     _eventsCount: 1,\n  //     _maxListeners: undefined,\n  //     [Symbol(shapeMode)]: false,\n  //     [Symbol(kCapture)]: false\n  //   } true\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\n\nIt is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  console.log(a, b, this);\n  // Prints: a b {}\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nAsynchronous vs. synchronous\n#\n\nThe EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  setImmediate(() => {\n    console.log('this happens asynchronously');\n  });\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 3043
        },
        "https://nodejs.org/api/events.html#eventstoppropagation": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#handling-events-only-once": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2361
        },
        "https://nodejs.org/api/events.html#eventemitterasyncresourceasyncid": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nPassing arguments and this to listeners\n#\n\nThe eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', function(a, b) {\n  console.log(a, b, this, this === myEmitter);\n  // Prints:\n  //   a b MyEmitter {\n  //     _events: [Object: null prototype] { event: [Function (anonymous)] },\n  //     _eventsCount: 1,\n  //     _maxListeners: undefined,\n  //     [Symbol(shapeMode)]: false,\n  //     [Symbol(kCapture)]: false\n  //   } true\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\n\nIt is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  console.log(a, b, this);\n  // Prints: a b {}\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nAsynchronous vs. synchronous\n#\n\nThe EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  setImmediate(() => {\n    console.log('this happens asynchronously');\n  });\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.",
            "word_count": 3399
        },
        "https://nodejs.org/api/events.html#class-customevent": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 3160
        },
        "https://nodejs.org/api/events.html#eventcancelable": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2594
        },
        "https://nodejs.org/api/events.html#event-removelistener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2669
        },
        "https://nodejs.org/api/events.html#eventserrormonitor": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.",
            "word_count": 2733
        },
        "https://nodejs.org/api/events.html#eventcurrenttarget": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238
        },
        "https://nodejs.org/api/events.html#class-eventemitter": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY\nCapture rejections of promises\n#\n\nUsing async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\nee.on('something', async (value) => {\n  throw new Error('kaboom');\n});\nCOPY\n\nThe captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none.\n\nconst EventEmitter = require('node:events');\nconst ee1 = new EventEmitter({ captureRejections: true });\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\n\nconst ee2 = new EventEmitter({ captureRejections: true });\nee2.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee2[Symbol.for('nodejs.rejection')] = console.log;\nCOPY\n\nSetting events.captureRejections = true will change the default for all new instances of EventEmitter.\n\nconst events = require('node:events');\nevents.captureRejections = true;\nconst ee1 = new events.EventEmitter();\nee1.on('something', async (value) => {\n  throw new Error('kaboom');\n});\n\nee1.on('error', console.log);\nCOPY\n\nThe 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.\n\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2792
        },
        "https://nodejs.org/api/events.html#emitteronceeventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nStability: 2 - Stable\nSource Code: lib/events.js\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n  console.log('an event occurred!');\nThe EventEmitter class is defined and exposed by the node:events module:\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\nIt supports the following option:\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\neventName <string> | <symbol> The event name\nThe 'removeListener' event is emitted after the listener is removed.\nAlias for emitter.on(eventName, listener).\nReturns: <boolean>\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\nReturns true if the event had listeners, false otherwise.\nconst myEmitter = new EventEmitter();\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\nconsole.log(myEmitter.listeners('event'));\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nReturns: <Array>\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nAdded in: v1.0.0\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\nReturns a copy of the array of listeners for the event named eventName.\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nAdded in: v10.0.0\nAlias for emitter.removeListener().\nAdded in: v0.1.101\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nAdded in: v0.3.0\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\nserver.once('connection', (stream) => {\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\nserver.prependListener('connection', (stream) => {\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\nserver.prependOnceListener('connection', (stream) => {\nRemoves all listeners, or those of the specified eventName.\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\nRemoves the specified listener from the listener array for the event named eventName.\nconst callback = (stream) => {\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\nconst callbackA = () => {\n  myEmitter.removeListener('event', callbackB);\nconst callbackB = () => {\n  console.log('B');\nmyEmitter.on('event', callbackA);\nmyEmitter.on('event', callbackB);\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\n// callbackB is now removed.\n// Internal listener array [callbackA]\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\nconst ee = new EventEmitter();\nfunction pong() {\n  console.log('pong');\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\nAdded in: v0.3.5\nn <integer>\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\nAdded in: v9.4.0\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nerr Error\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  destroy(err) {\n    // Tear the resource down here.",
            "filtered_word_count": 1694
        },
        "https://nodejs.org/api/events.html#emitterprependoncelistenereventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#passing-arguments-and-this-to-listeners": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nPassing arguments and this to listeners\n#\n\nThe eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', function(a, b) {\n  console.log(a, b, this, this === myEmitter);\n  // Prints:\n  //   a b MyEmitter {\n  //     _events: [Object: null prototype] { event: [Function (anonymous)] },\n  //     _eventsCount: 1,\n  //     _maxListeners: undefined,\n  //     [Symbol(shapeMode)]: false,\n  //     [Symbol(kCapture)]: false\n  //   } true\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\n\nIt is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  console.log(a, b, this);\n  // Prints: a b {}\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nAsynchronous vs. synchronous\n#\n\nThe EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', (a, b) => {\n  setImmediate(() => {\n    console.log('this happens asynchronously');\n  });\n});\nmyEmitter.emit('event', 'a', 'b');\nCOPY\nHandling events only once\n#\n\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.on('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Prints: 2\nCOPY\n\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nlet m = 0;\nmyEmitter.once('event', () => {\n  console.log(++m);\n});\nmyEmitter.emit('event');\n// Prints: 1\nmyEmitter.emit('event');\n// Ignored\nCOPY\nError events\n#\n\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\n\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.emit('error', new Error('whoops!'));\n// Throws and crashes Node.js\nCOPY\n\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\n\nAs a best practice, listeners should always be added for the 'error' events.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Prints: whoops! there was an error\nCOPY\n\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\n\nconst { EventEmitter, errorMonitor } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n});\nmyEmitter.emit('error', new Error('whoops!'));\n// Still throws and crashes Node.js\nCOPY",
            "word_count": 1068,
            "filtered_content": "The eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\nmyEmitter.on('event', function(a, b) {\n  console.log(a, b, this, this === myEmitter);\n  // Prints:\n  //   a b MyEmitter {\n  //     _events: [Object: null prototype] { event: [Function (anonymous)] },\n  //     _eventsCount: 1,\n  //     _maxListeners: undefined,\n  //     [Symbol(shapeMode)]: false,\n  //     [Symbol(kCapture)]: false\n  //   } true\nIt is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance:\n  console.log(a, b, this);\n  // Prints: a b {}\nThe EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:\n  setImmediate(() => {\n    console.log('this happens asynchronously');\n  });\nWhen a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted.\n// Prints: 2\nUsing the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.\nmyEmitter.once('event', () => {\n// Ignored\nWhen an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js.\nIf an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.\n// Throws and crashes Node.js\nTo guard against crashing the Node.js process the domain module can be used. (Note, however, that the node:domain module is deprecated.)\nAs a best practice, listeners should always be added for the 'error' events.\nmyEmitter.on('error', (err) => {\n  console.error('whoops! there was an error');\n// Prints: whoops! there was an error\nIt is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol events.errorMonitor.\nconst { EventEmitter, errorMonitor } = require('node:events');\nmyEmitter.on(errorMonitor, (err) => {\n  MyMonitoringTool.log(err);\n// Still throws and crashes Node.js",
            "filtered_word_count": 390
        },
        "https://nodejs.org/api/events.html#emitterprependlistenereventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetoncetype-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "The EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\nThe return value of a handler function is ignored.\nHandlers are always invoked in the order they were added.\nHandler functions may mutate the event object.\nfunction handler1(event) {\n  event.a = 1;\nasync function handler2(event) {\n  console.log(event.a);  // Prints 1\nconst handler3 = {\n  handleEvent(event) {\nconst handler4 = {\n  async handleEvent(event) {\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\nThrowing within an event listener will not stop the other registered handlers from being invoked.\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\nStability: 3 - Legacy: Use event.stopPropagation() instead.\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\nType: <boolean> True if the event was created with the cancelable option.\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\nIs true if cancelable is true and event.preventDefault() has been called.\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\nAdded in: v19.5.0\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\nbubbles <boolean>\ncancelable <boolean>\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\nSets the defaultPrevented property to true if cancelable is true.\nStability: 3 - Legacy: Use event.defaultPrevented instead.\nType: <boolean> True if the event has not been canceled.\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\nStability: 3 - Legacy: Use event.target instead.\nStops the invocation of event listeners after the current one completes.\nType: <number>\nThe millisecond timestamp when the Event object was created.\nType: <string>\nThe event type identifier.\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\nfunction handler(event) {}\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\nDispatches the event to the list of handlers for event.type.\nThe registered event listeners is synchronously invoked in the order they were registered.\nRemoves the listener from the list of handlers for event type.\nExtends: <Event>\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\nType: <any> Returns custom data passed when initializing.\nRead-only.\nExtends: <EventTarget>\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\nAdded in: v15.2.0\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\nReturns: <string[]>\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\nn <number>\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\nNode.js-specific alias for eventTarget.removeEventListener().\nNode.js-specific alias for eventTarget.addEventListener().\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "filtered_word_count": 1307
        },
        "https://nodejs.org/api/events.html#class-event": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 3160,
            "filtered_content": "emitter <EventEmitter>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\n  for await (const event of on(ee, 'foo')) {\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\nAn <AbortSignal> can be used to cancel waiting on events:\nconst ac = new AbortController();\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\nprocess.nextTick(() => ac.abort());\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\nsetMaxListeners(5, target, emitter);\nAdded in: v20.5.0, v18.18.0\nStability: 1 - Experimental\nsignal <AbortSignal>\nReturns: <Disposable> A Disposable that removes the abort listener.\nListens once to the abort event on the provided signal.\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\nReturns a disposable so that it may be unsubscribed from more easily.\nconst { addAbortListener } = require('node:events');\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n  } finally {\n    disposable?.[Symbol.dispose]();\nAdded in: v17.4.0, v16.14.0\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\nconst ee2 = new EventEmitter();\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\nType: <number> The unique asyncId assigned to the resource.\nType: The underlying <AsyncResource>.\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.",
            "filtered_word_count": 707
        },
        "https://nodejs.org/api/events.html#eventbubbles": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetaddlistenertype-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventsgeteventlistenersemitterortarget-eventname": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY",
            "word_count": 3265,
            "filtered_content": "Added in: v0.11.2\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\nAdded in: v13.6.0, v12.17.0\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\nAdded in: v15.2.0, v14.17.0\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\nconst { getEventListeners, EventEmitter } = require('node:events');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\nAdded in: v19.9.0, v18.17.0\nReturns the currently set max amount of listeners.\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\nname <string>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\nconst { once, EventEmitter } = require('node:events');\nasync function run() {\n    ee.emit('myevent', 42);\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n  const err = new Error('kaboom');\n    ee.emit('error', err);\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\nrun();\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\nee.emit('error', new Error('boom'));\n// Prints: ok boom\nAn <AbortSignal> can be used to cancel waiting for the event:\nasync function foo(emitter, event, signal) {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n  await once(myEE, 'bar');\n  console.log('bar');\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');",
            "filtered_word_count": 789
        },
        "https://nodejs.org/api/events.html#eventsonemitter-eventname-options": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\nevents.captureRejections\n#\nHistory\n\nValue: <boolean>\n\nChange the default captureRejections option on all new EventEmitter objects.\n\nevents.captureRejectionSymbol\n#\nHistory\n\nValue: Symbol.for('nodejs.rejection')\n\nSee how to write a custom rejection handler.\n\nevents.listenerCount(emitter, eventName)\n#\nAdded in: v0.9.12Deprecated since: v3.2.0\n\nStability: 0 - Deprecated: Use emitter.listenerCount() instead.\n\nemitter <EventEmitter> The emitter to query\neventName <string> | <symbol> The event name\n\nA class method that returns the number of listeners for the given eventName registered on the given emitter.\n\nconst { EventEmitter, listenerCount } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY",
            "word_count": 1647,
            "filtered_content": "Value: <boolean>\nChange the default captureRejections option on all new EventEmitter objects.\nValue: Symbol.for('nodejs.rejection')\nSee how to write a custom rejection handler.\nAdded in: v0.9.12Deprecated since: v3.2.0\nStability: 0 - Deprecated: Use emitter.listenerCount() instead.\nemitter <EventEmitter> The emitter to query\nA class method that returns the number of listeners for the given eventName registered on the given emitter.\nconst { EventEmitter, listenerCount } = require('node:events');\nconsole.log(listenerCount(myEmitter, 'event'));",
            "filtered_word_count": 67
        },
        "https://nodejs.org/api/events.html#nodeeventtargetremovealllistenerstype": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventscapturerejections": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\nevents.captureRejections\n#\nHistory\n\nValue: <boolean>\n\nChange the default captureRejections option on all new EventEmitter objects.\n\nevents.captureRejectionSymbol\n#\nHistory\n\nValue: Symbol.for('nodejs.rejection')\n\nSee how to write a custom rejection handler.\n\nevents.listenerCount(emitter, eventName)\n#\nAdded in: v0.9.12Deprecated since: v3.2.0\n\nStability: 0 - Deprecated: Use emitter.listenerCount() instead.\n\nemitter <EventEmitter> The emitter to query\neventName <string> | <symbol> The event name\n\nA class method that returns the number of listeners for the given eventName registered on the given emitter.\n\nconst { EventEmitter, listenerCount } = require('node:events');\n\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY",
            "word_count": 1482,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventemitterasyncresourcetriggerasyncid": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2759,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#emittergetmaxlisteners": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodejs-eventtarget-vs-dom-eventtarget": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2594,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#emitterlistenerseventname": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventeventphase": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#emitteroffeventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventsrcelement": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetemittype-arg": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventsaddabortlistenersignal-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.on(emitter, eventName[, options])\n#\nHistory\nemitter <EventEmitter>\neventName <string> | <symbol> The name of the event being listened for\noptions <Object>\nsignal <AbortSignal> Can be used to cancel awaiting events.\nclose - <string[]> Names of events that will end the iteration.\nhighWaterMark - <integer> Default: Number.MAX_SAFE_INTEGER The high watermark. The emitter is paused every time the size of events being buffered is higher than it. Supported only on emitters implementing pause() and resume() methods.\nlowWaterMark - <integer> Default: 1 The low watermark. The emitter is resumed every time the size of events being buffered is lower than it. Supported only on emitters implementing pause() and resume() methods.\nReturns: <AsyncIterator> that iterates eventName events emitted by the emitter\nconst { on, EventEmitter } = require('node:events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\nCOPY\n\nReturns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments.\n\nAn <AbortSignal> can be used to cancel waiting on events:\n\nconst { on, EventEmitter } = require('node:events');\n\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\nCOPY\nevents.setMaxListeners(n[, ...eventTargets])\n#\nAdded in: v15.4.0\nn <number> A non-negative number. The maximum number of listeners per EventTarget event.\n...eventsTargets <EventTarget[]> | <EventEmitter[]> Zero or more <EventTarget> or <EventEmitter> instances. If none are specified, n is set as the default max for all newly created <EventTarget> and <EventEmitter> objects.\nconst {\n  setMaxListeners,\n  EventEmitter,\n} = require('node:events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 3160,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventemitterasyncresourceemitdestroy": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2759,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventsdefaultmaxlisteners": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY",
            "word_count": 3265,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventtimestamp": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventtarget-and-event-api": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nevents.addAbortListener(signal, listener)\n#\nAdded in: v20.5.0, v18.18.0\n\nStability: 1 - Experimental\n\nsignal <AbortSignal>\nlistener <Function> | <EventListener>\nReturns: <Disposable> A Disposable that removes the abort listener.\n\nListens once to the abort event on the provided signal.\n\nListening to the abort event on abort signals is unsafe and may lead to resource leaks since another third party with the signal can call e.stopImmediatePropagation(). Unfortunately Node.js cannot change this since it would violate the web standard. Additionally, the original API makes it easy to forget to remove listeners.\n\nThis API allows safely using AbortSignals in Node.js APIs by solving these two issues by listening to the event such that stopImmediatePropagation does not prevent the listener from running.\n\nReturns a disposable so that it may be unsubscribed from more easily.\n\nconst { addAbortListener } = require('node:events');\n\nfunction example(signal) {\n  let disposable;\n  try {\n    signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n    disposable = addAbortListener(signal, (e) => {\n      // Do something when signal is aborted.\n    });\n  } finally {\n    disposable?.[Symbol.dispose]();\n  }\n}\nCOPY\nClass: events.EventEmitterAsyncResource extends EventEmitter\n#\nAdded in: v17.4.0, v16.14.0\n\nIntegrates EventEmitter with <AsyncResource> for EventEmitters that require manual async tracking. Specifically, all events emitted by instances of events.EventEmitterAsyncResource will run within its async context.\n\nconst { EventEmitterAsyncResource, EventEmitter } = require('node:events');\nconst { notStrictEqual, strictEqual } = require('node:assert');\nconst { executionAsyncId, triggerAsyncId } = require('node:async_hooks');\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\nCOPY\n\nThe EventEmitterAsyncResource class has the same methods and takes the same options as EventEmitter and AsyncResource themselves.\n\nnew events.EventEmitterAsyncResource([options])\n#\noptions <Object>\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nname <string> The type of async event. Default: new.target.name.\ntriggerAsyncId <number> The ID of the execution context that created this async event. Default: executionAsyncId().\nrequireManualDestroy <boolean> If set to true, disables emitDestroy when the object is garbage collected. This usually does not need to be set (even if emitDestroy is called manually), unless the resource's asyncId is retrieved and the sensitive API's emitDestroy is called with it. When set to false, the emitDestroy call on garbage collection will only take place if there is at least one active destroy hook. Default: false.\neventemitterasyncresource.asyncId\n#\nType: <number> The unique asyncId assigned to the resource.\neventemitterasyncresource.asyncResource\n#\nType: The underlying <AsyncResource>.\n\nThe returned AsyncResource object has an additional eventEmitter property that provides a reference to this EventEmitterAsyncResource.\n\neventemitterasyncresource.emitDestroy()\n#\n\nCall all destroy hooks. This should only ever be called once. An error will be thrown if it is called more than once. This must be manually called. If the resource is left to be collected by the GC then the destroy hooks will never be called.\n\neventemitterasyncresource.triggerAsyncId\n#\nType: <number> The same triggerAsyncId that is passed to the AsyncResource constructor.\n\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2759,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventsgetmaxlistenersemitterortarget": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY\nevents.once(emitter, name[, options])\n#\nHistory\nemitter <EventEmitter>\nname <string>\noptions <Object>\nsignal <AbortSignal> Can be used to cancel waiting for the event.\nReturns: <Promise>\n\nCreates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event.\n\nThis method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event.\n\nconst { once, EventEmitter } = require('node:events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.error('error happened', err);\n  }\n}\n\nrun();\nCOPY\n\nThe special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.error('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\nCOPY\n\nAn <AbortSignal> can be used to cancel waiting for the event:\n\nconst { EventEmitter, once } = require('node:events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\nCOPY\nAwaiting multiple events emitted on process.nextTick()\n#\n\nThere is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event.\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await once(myEE, 'bar');\n  console.log('bar');\n\n  // This Promise will never resolve because the 'foo' event will\n  // have already been emitted before the Promise is created.\n  await once(myEE, 'foo');\n  console.log('foo');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY\n\nTo catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled():\n\nconst { EventEmitter, once } = require('node:events');\n\nconst myEE = new EventEmitter();\n\nasync function foo() {\n  await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);\n  console.log('foo', 'bar');\n}\n\nprocess.nextTick(() => {\n  myEE.emit('bar');\n  myEE.emit('foo');\n});\n\nfoo().then(() => console.log('done'));\nCOPY",
            "word_count": 3265,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetontype-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventtype": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetlistenercounttype": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#emitteroneventname-listener": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY",
            "word_count": 2258,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetremovelistenertype-listener-options": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#eventdefaultprevented": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#nodeeventtargetgetmaxlisteners": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nEventTarget and Event API\n#\nHistory\n\nThe EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs.\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', (event) => {\n  console.log('foo event happened!');\n}); \nCOPY\nNode.js EventTarget vs. DOM EventTarget\n#\n\nThere are two key differences between the Node.js EventTarget and the EventTarget Web API:\n\nWhereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event.\nIn the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details).\nNodeEventTarget vs. EventEmitter\n#\n\nThe NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.\n\nUnlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored.\nThe NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted.\nThe NodeEventTarget does not implement any special default behavior for events with type 'error'.\nThe NodeEventTarget supports EventListener objects as well as functions as handlers for all event types.\nEvent listener\n#\n\nEvent listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function.\n\nIn either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function.\n\nAsync functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling.\n\nAn error thrown by one handler function does not prevent the other handlers from being invoked.\n\nThe return value of a handler function is ignored.\n\nHandlers are always invoked in the order they were added.\n\nHandler functions may mutate the event object.\n\nfunction handler1(event) {\n  console.log(event.type);  // Prints 'foo'\n  event.a = 1;\n}\n\nasync function handler2(event) {\n  console.log(event.type);  // Prints 'foo'\n  console.log(event.a);  // Prints 1\n}\n\nconst handler3 = {\n  handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst handler4 = {\n  async handleEvent(event) {\n    console.log(event.type);  // Prints 'foo'\n  },\n};\n\nconst target = new EventTarget();\n\ntarget.addEventListener('foo', handler1);\ntarget.addEventListener('foo', handler2);\ntarget.addEventListener('foo', handler3);\ntarget.addEventListener('foo', handler4, { once: true }); \nCOPY\nEventTarget error handling\n#\n\nWhen a registered event listener throws (or returns a Promise that rejects), by default the error is treated as an uncaught exception on process.nextTick(). This means uncaught exceptions in EventTargets will terminate the Node.js process by default.\n\nThrowing within an event listener will not stop the other registered handlers from being invoked.\n\nThe EventTarget does not implement any special default handling for 'error' type events like EventEmitter.\n\nCurrently errors are first forwarded to the process.on('error') event before reaching process.on('uncaughtException'). This behavior is deprecated and will change in a future release to align EventTarget with other Node.js APIs. Any code relying on the process.on('error') event should be aligned with the new behavior.\n\nClass: Event\n#\nHistory\n\nThe Event object is an adaptation of the Event Web API. Instances are created internally by Node.js.\n\nevent.bubbles\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.cancelBubble\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.stopPropagation() instead.\n\nType: <boolean>\n\nAlias for event.stopPropagation() if set to true. This is not used in Node.js and is provided purely for completeness.\n\nevent.cancelable\n#\nAdded in: v14.5.0\nType: <boolean> True if the event was created with the cancelable option.\nevent.composed\n#\nAdded in: v14.5.0\nType: <boolean> Always returns false.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.composedPath()\n#\nAdded in: v14.5.0\n\nReturns an array containing the current EventTarget as the only entry or empty if the event is not being dispatched. This is not used in Node.js and is provided purely for completeness.\n\nevent.currentTarget\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.defaultPrevented\n#\nAdded in: v14.5.0\nType: <boolean>\n\nIs true if cancelable is true and event.preventDefault() has been called.\n\nevent.eventPhase\n#\nAdded in: v14.5.0\nType: <number> Returns 0 while an event is not being dispatched, 2 while it is being dispatched.\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.initEvent(type[, bubbles[, cancelable]])\n#\nAdded in: v19.5.0\n\nStability: 3 - Legacy: The WHATWG spec considers it deprecated and users shouldn't use it at all.\n\ntype <string>\nbubbles <boolean>\ncancelable <boolean>\n\nRedundant with event constructors and incapable of setting composed. This is not used in Node.js and is provided purely for completeness.\n\nevent.isTrusted\n#\nAdded in: v14.5.0\nType: <boolean>\n\nThe <AbortSignal> \"abort\" event is emitted with isTrusted set to true. The value is false in all other cases.\n\nevent.preventDefault()\n#\nAdded in: v14.5.0\n\nSets the defaultPrevented property to true if cancelable is true.\n\nevent.returnValue\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.defaultPrevented instead.\n\nType: <boolean> True if the event has not been canceled.\n\nThe value of event.returnValue is always the opposite of event.defaultPrevented. This is not used in Node.js and is provided purely for completeness.\n\nevent.srcElement\n#\nAdded in: v14.5.0\n\nStability: 3 - Legacy: Use event.target instead.\n\nType: <EventTarget> The EventTarget dispatching the event.\n\nAlias for event.target.\n\nevent.stopImmediatePropagation()\n#\nAdded in: v14.5.0\n\nStops the invocation of event listeners after the current one completes.\n\nevent.stopPropagation()\n#\nAdded in: v14.5.0\n\nThis is not used in Node.js and is provided purely for completeness.\n\nevent.target\n#\nAdded in: v14.5.0\nType: <EventTarget> The EventTarget dispatching the event.\nevent.timeStamp\n#\nAdded in: v14.5.0\nType: <number>\n\nThe millisecond timestamp when the Event object was created.\n\nevent.type\n#\nAdded in: v14.5.0\nType: <string>\n\nThe event type identifier.\n\nClass: EventTarget\n#\nHistory\neventTarget.addEventListener(type, listener[, options])\n#\nHistory\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\nonce <boolean> When true, the listener is automatically removed when it is first invoked. Default: false.\npassive <boolean> When true, serves as a hint that the listener will not call the Event object's preventDefault() method. Default: false.\ncapture <boolean> Not directly used by Node.js. Added for API completeness. Default: false.\nsignal <AbortSignal> The listener will be removed when the given AbortSignal object's abort() method is called.\n\nAdds a new handler for the type event. Any given listener is added only once per type and per capture option value.\n\nIf the once option is true, the listener is removed after the next time a type event is dispatched.\n\nThe capture option is not used by Node.js in any functional way other than tracking registered event listeners per the EventTarget specification. Specifically, the capture option is used as part of the key when registering a listener. Any individual listener may be added once with capture = false, and once with capture = true.\n\nfunction handler(event) {}\n\nconst target = new EventTarget();\ntarget.addEventListener('foo', handler, { capture: true });  // first\ntarget.addEventListener('foo', handler, { capture: false }); // second\n\n// Removes the second instance of handler\ntarget.removeEventListener('foo', handler);\n\n// Removes the first instance of handler\ntarget.removeEventListener('foo', handler, { capture: true }); \nCOPY\neventTarget.dispatchEvent(event)\n#\nAdded in: v14.5.0\nevent <Event>\nReturns: <boolean> true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, otherwise false.\n\nDispatches the event to the list of handlers for event.type.\n\nThe registered event listeners is synchronously invoked in the order they were registered.\n\neventTarget.removeEventListener(type, listener[, options])\n#\nAdded in: v14.5.0\ntype <string>\nlistener <Function> | <EventListener>\noptions <Object>\ncapture <boolean>\n\nRemoves the listener from the list of handlers for event type.\n\nClass: CustomEvent\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nExtends: <Event>\n\nThe CustomEvent object is an adaptation of the CustomEvent Web API. Instances are created internally by Node.js.\n\nevent.detail\n#\nAdded in: v18.7.0, v16.17.0\n\nStability: 1 - Experimental.\n\nType: <any> Returns custom data passed when initializing.\n\nRead-only.\n\nClass: NodeEventTarget\n#\nAdded in: v14.5.0\nExtends: <EventTarget>\n\nThe NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API.\n\nnodeEventTarget.addListener(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that emulates the equivalent EventEmitter API. The only difference between addListener() and addEventListener() is that addListener() will return a reference to the EventTarget.\n\nnodeEventTarget.emit(type, arg)\n#\nAdded in: v15.2.0\ntype <string>\narg <any>\nReturns: <boolean> true if event listeners registered for the type exist, otherwise false.\n\nNode.js-specific extension to the EventTarget class that dispatches the arg to the list of handlers for type.\n\nnodeEventTarget.eventNames()\n#\nAdded in: v14.5.0\nReturns: <string[]>\n\nNode.js-specific extension to the EventTarget class that returns an array of event type names for which event listeners are registered.\n\nnodeEventTarget.listenerCount(type)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of event listeners registered for the type.\n\nnodeEventTarget.setMaxListeners(n)\n#\nAdded in: v14.5.0\nn <number>\n\nNode.js-specific extension to the EventTarget class that sets the number of max event listeners as n.\n\nnodeEventTarget.getMaxListeners()\n#\nAdded in: v14.5.0\nReturns: <number>\n\nNode.js-specific extension to the EventTarget class that returns the number of max event listeners.\n\nnodeEventTarget.off(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.removeEventListener().\n\nnodeEventTarget.on(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific alias for eventTarget.addEventListener().\n\nnodeEventTarget.once(type, listener)\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that adds a once listener for the given event type. This is equivalent to calling on with the once option set to true.\n\nnodeEventTarget.removeAllListeners([type])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class. If type is specified, removes all registered listeners for type, otherwise removes all registered listeners.\n\nnodeEventTarget.removeListener(type, listener[, options])\n#\nAdded in: v14.5.0\n\ntype <string>\n\nlistener <Function> | <EventListener>\n\noptions <Object>\n\ncapture <boolean>\n\nReturns: <EventTarget> this\n\nNode.js-specific extension to the EventTarget class that removes the listener for the given type. The only difference between removeListener() and removeEventListener() is that removeListener() will return a reference to the EventTarget.",
            "word_count": 2238,
            "filtered_content": "",
            "filtered_word_count": 0
        },
        "https://nodejs.org/api/events.html#emittersymbolfornodejsrejectionerr-eventname-args": {
            "status": "Looks good",
            "content": "Node.js\nAbout this documentation\nUsage and example\nAssertion testing\nAsynchronous context tracking\nAsync hooks\nBuffer\nC++ addons\nC/C++ addons with Node-API\nC++ embedder API\nChild processes\nCluster\nCommand-line options\nConsole\nCorepack\nCrypto\nDebugger\nDeprecated APIs\nDiagnostics Channel\nDNS\nDomain\nErrors\nEvents\nFile system\nGlobals\nHTTP\nHTTP/2\nHTTPS\nInspector\nInternationalization\nModules: CommonJS modules\nModules: ECMAScript modules\nModules: node:module API\nModules: Packages\nNet\nOS\nPath\nPerformance hooks\nPermissions\nProcess\nPunycode\nQuery strings\nReadline\nREPL\nReport\nSingle executable applications\nStream\nString decoder\nTest runner\nTimers\nTLS/SSL\nTrace events\nTTY\nUDP/datagram\nURL\nUtilities\nV8\nVM\nWASI\nWeb Crypto API\nWeb Streams API\nWorker threads\nZlib\nCode repository and issue tracker\nNode.js v22.0.0  Table of contents  Index  Other versions  Options\nTable of contents\nEvents\nPassing arguments and this to listeners\nAsynchronous vs. synchronous\nHandling events only once\nError events\nCapture rejections of promises\nClass: EventEmitter\nEvent: 'newListener'\nEvent: 'removeListener'\nemitter.addListener(eventName, listener)\nemitter.emit(eventName[, ...args])\nemitter.eventNames()\nemitter.getMaxListeners()\nemitter.listenerCount(eventName[, listener])\nemitter.listeners(eventName)\nemitter.off(eventName, listener)\nemitter.on(eventName, listener)\nemitter.once(eventName, listener)\nemitter.prependListener(eventName, listener)\nemitter.prependOnceListener(eventName, listener)\nemitter.removeAllListeners([eventName])\nemitter.removeListener(eventName, listener)\nemitter.setMaxListeners(n)\nemitter.rawListeners(eventName)\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\nevents.defaultMaxListeners\nevents.errorMonitor\nevents.getEventListeners(emitterOrTarget, eventName)\nevents.getMaxListeners(emitterOrTarget)\nevents.once(emitter, name[, options])\nAwaiting multiple events emitted on process.nextTick()\nevents.captureRejections\nevents.captureRejectionSymbol\nevents.listenerCount(emitter, eventName)\nevents.on(emitter, eventName[, options])\nevents.setMaxListeners(n[, ...eventTargets])\nevents.addAbortListener(signal, listener)\nClass: events.EventEmitterAsyncResource extends EventEmitter\nnew events.EventEmitterAsyncResource([options])\neventemitterasyncresource.asyncId\neventemitterasyncresource.asyncResource\neventemitterasyncresource.emitDestroy()\neventemitterasyncresource.triggerAsyncId\nEventTarget and Event API\nNode.js EventTarget vs. DOM EventTarget\nNodeEventTarget vs. EventEmitter\nEvent listener\nEventTarget error handling\nClass: Event\nevent.bubbles\nevent.cancelBubble\nevent.cancelable\nevent.composed\nevent.composedPath()\nevent.currentTarget\nevent.defaultPrevented\nevent.eventPhase\nevent.initEvent(type[, bubbles[, cancelable]])\nevent.isTrusted\nevent.preventDefault()\nevent.returnValue\nevent.srcElement\nevent.stopImmediatePropagation()\nevent.stopPropagation()\nevent.target\nevent.timeStamp\nevent.type\nClass: EventTarget\neventTarget.addEventListener(type, listener[, options])\neventTarget.dispatchEvent(event)\neventTarget.removeEventListener(type, listener[, options])\nClass: CustomEvent\nevent.detail\nClass: NodeEventTarget\nnodeEventTarget.addListener(type, listener)\nnodeEventTarget.emit(type, arg)\nnodeEventTarget.eventNames()\nnodeEventTarget.listenerCount(type)\nnodeEventTarget.setMaxListeners(n)\nnodeEventTarget.getMaxListeners()\nnodeEventTarget.off(type, listener[, options])\nnodeEventTarget.on(type, listener)\nnodeEventTarget.once(type, listener)\nnodeEventTarget.removeAllListeners([type])\nnodeEventTarget.removeListener(type, listener[, options])\nEvents\n#\n\nStability: 2 - Stable\n\nSource Code: lib/events.js\n\nMuch of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called.\n\nFor instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.\n\nAll objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used.\n\nWhen the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded.\n\nThe following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event.\n\nconst EventEmitter = require('node:events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n  console.log('an event occurred!');\n});\nmyEmitter.emit('event');\nCOPY\nClass: EventEmitter\n#\nHistory\n\nThe EventEmitter class is defined and exposed by the node:events module:\n\nconst EventEmitter = require('node:events');\nCOPY\n\nAll EventEmitters emit the event 'newListener' when new listeners are added and 'removeListener' when existing listeners are removed.\n\nIt supports the following option:\n\ncaptureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.\nEvent: 'newListener'\n#\nAdded in: v0.1.26\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\n\nThe EventEmitter instance will emit its own 'newListener' event before a listener is added to its internal array of listeners.\n\nListeners registered for the 'newListener' event are passed the event name and a reference to the listener being added.\n\nThe fact that the event is triggered before adding the listener has a subtle but important side effect: any additional listeners registered to the same name within the 'newListener' callback are inserted before the listener that is in the process of being added.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n// Only do this once so we don't loop forever\nmyEmitter.once('newListener', (event, listener) => {\n  if (event === 'event') {\n    // Insert a new listener in front\n    myEmitter.on('event', () => {\n      console.log('B');\n    });\n  }\n});\nmyEmitter.on('event', () => {\n  console.log('A');\n});\nmyEmitter.emit('event');\n// Prints:\n//   B\n//   A\nCOPY\nEvent: 'removeListener'\n#\nHistory\neventName <string> | <symbol> The event name\nlistener <Function> The event handler function\n\nThe 'removeListener' event is emitted after the listener is removed.\n\nemitter.addListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\n\nAlias for emitter.on(eventName, listener).\n\nemitter.emit(eventName[, ...args])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\n...args <any>\nReturns: <boolean>\n\nSynchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.\n\nReturns true if the event had listeners, false otherwise.\n\nconst EventEmitter = require('node:events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\nCOPY\nemitter.eventNames()\n#\nAdded in: v6.0.0\nReturns: <Array>\n\nReturns an array listing the events for which the emitter has registered listeners. The values in the array are strings or Symbols.\n\nconst EventEmitter = require('node:events');\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\nCOPY\nemitter.getMaxListeners()\n#\nAdded in: v1.0.0\nReturns: <integer>\n\nReturns the current max listener value for the EventEmitter which is either set by emitter.setMaxListeners(n) or defaults to events.defaultMaxListeners.\n\nemitter.listenerCount(eventName[, listener])\n#\nHistory\neventName <string> | <symbol> The name of the event being listened for\nlistener <Function> The event handler function\nReturns: <integer>\n\nReturns the number of listeners listening for the event named eventName. If listener is provided, it will return how many times the listener is found in the list of the listeners of the event.\n\nemitter.listeners(eventName)\n#\nHistory\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ] \nCOPY\nemitter.off(eventName, listener)\n#\nAdded in: v10.0.0\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nAlias for emitter.removeListener().\n\nemitter.on(eventName, listener)\n#\nAdded in: v0.1.101\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => console.log('a'));\nmyEE.prependListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.once(eventName, listener)\n#\nAdded in: v0.3.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.\n\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The emitter.prependOnceListener() method can be used as an alternative to add the event listener to the beginning of the listeners array.\n\nconst EventEmitter = require('node:events');\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\nCOPY\nemitter.prependListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds the listener function to the beginning of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times.\n\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.prependOnceListener(eventName, listener)\n#\nAdded in: v6.0.0\neventName <string> | <symbol> The name of the event.\nlistener <Function> The callback function\nReturns: <EventEmitter>\n\nAdds a one-time listener function for the event named eventName to the beginning of the listeners array. The next time eventName is triggered, this listener is removed, and then invoked.\n\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n}); \nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeAllListeners([eventName])\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nReturns: <EventEmitter>\n\nRemoves all listeners, or those of the specified eventName.\n\nIt is bad practice to remove listeners added elsewhere in the code, particularly when the EventEmitter instance was created by some other component or module (e.g. sockets or file streams).\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.removeListener(eventName, listener)\n#\nAdded in: v0.1.26\neventName <string> | <symbol>\nlistener <Function>\nReturns: <EventEmitter>\n\nRemoves the specified listener from the listener array for the event named eventName.\n\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback); \nCOPY\n\nremoveListener() will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified eventName, then removeListener() must be called multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any removeListener() or removeAllListeners() calls after emitting and before the last listener finishes execution will not remove them from emit() in progress. Subsequent events behave as expected.\n\nconst EventEmitter = require('node:events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\nCOPY\n\nBecause listeners are managed using an internal array, calling this will change the position indexes of any listener registered after the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the emitter.listeners() method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single event (as in the example below), removeListener() will remove the most recently added instance. In the example the once('ping') listener is removed:\n\nconst EventEmitter = require('node:events');\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\nCOPY\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.setMaxListeners(n)\n#\nAdded in: v0.3.5\nn <integer>\nReturns: <EventEmitter>\n\nBy default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default that helps finding memory leaks. The emitter.setMaxListeners() method allows the limit to be modified for this specific EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited number of listeners.\n\nReturns a reference to the EventEmitter, so that calls can be chained.\n\nemitter.rawListeners(eventName)\n#\nAdded in: v9.4.0\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName, including any wrappers (such as those created by .once()).\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\nCOPY\nemitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])\n#\nHistory\nerr Error\neventName <string> | <symbol>\n...args <any>\n\nThe Symbol.for('nodejs.rejection') method is called in case a promise rejection happens when emitting an event and captureRejections is enabled on the emitter. It is possible to use events.captureRejectionSymbol in place of Symbol.for('nodejs.rejection').\n\nconst { EventEmitter, captureRejectionSymbol } = require('node:events');\n\nclass MyClass extends EventEmitter {\n  constructor() {\n    super({ captureRejections: true });\n  }\n\n  [captureRejectionSymbol](err, event, ...args) {\n    console.log('rejection happened for', event, 'with', err, ...args);\n    this.destroy(err);\n  }\n\n  destroy(err) {\n    // Tear the resource down here.\n  }\n}\nCOPY\nevents.defaultMaxListeners\n#\nAdded in: v0.11.2\n\nBy default, a maximum of 10 listeners can be registered for any single event. This limit can be changed for individual EventEmitter instances using the emitter.setMaxListeners(n) method. To change the default for all EventEmitter instances, the events.defaultMaxListeners property can be used. If this value is not a positive number, a RangeError is thrown.\n\nTake caution when setting the events.defaultMaxListeners because the change affects all EventEmitter instances, including those created before the change is made. However, calling emitter.setMaxListeners(n) still has precedence over events.defaultMaxListeners.\n\nThis is not a hard limit. The EventEmitter instance will allow more listeners to be added but will output a trace warning to stderr indicating that a \"possible EventEmitter memory leak\" has been detected. For any single EventEmitter, the emitter.getMaxListeners() and emitter.setMaxListeners() methods can be used to temporarily avoid this warning:\n\nconst EventEmitter = require('node:events');\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\nCOPY\n\nThe --trace-warnings command-line flag can be used to display the stack trace for such warnings.\n\nThe emitted warning can be inspected with process.on('warning') and will have the additional emitter, type, and count properties, referring to the event emitter instance, the event's name and the number of attached listeners, respectively. Its name property is set to 'MaxListenersExceededWarning'.\n\nevents.errorMonitor\n#\nAdded in: v13.6.0, v12.17.0\n\nThis symbol shall be used to install a listener for only monitoring 'error' events. Listeners installed using this symbol are called before the regular 'error' listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an 'error' event is emitted. Therefore, the process will still crash if no regular 'error' listener is installed.\n\nevents.getEventListeners(emitterOrTarget, eventName)\n#\nAdded in: v15.2.0, v14.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\neventName <string> | <symbol>\nReturns: <Function[]>\n\nReturns a copy of the array of listeners for the event named eventName.\n\nFor EventEmitters this behaves exactly the same as calling .listeners on the emitter.\n\nFor EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.\n\nconst { getEventListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n}\nCOPY\nevents.getMaxListeners(emitterOrTarget)\n#\nAdded in: v19.9.0, v18.17.0\nemitterOrTarget <EventEmitter> | <EventTarget>\nReturns: <number>\n\nReturns the currently set max amount of listeners.\n\nFor EventEmitters this behaves exactly the same as calling .getMaxListeners on the emitter.\n\nFor EventTargets this is the only way to get the max event listeners for the event target. If the number of event handlers on a single EventTarget exceeds the max set, the EventTarget will print a warning.\n\nconst { getMaxListeners, setMaxListeners, EventEmitter } = require('node:events');\n\n{\n  const ee = new EventEmitter();\n  console.log(getMaxListeners(ee)); // 10\n  setMaxListeners(11, ee);\n  console.log(getMaxListeners(ee)); // 11\n}\n{\n  const et = new EventTarget();\n  console.log(getMaxListeners(et)); // 10\n  setMaxListeners(11, et);\n  console.log(getMaxListeners(et)); // 11\n}\nCOPY",
            "word_count": 2773,
            "filtered_content": "",
            "filtered_word_count": 0
        }
    }
}