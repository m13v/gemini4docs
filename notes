storing api keys, where should the user include api key?
troubleshoot message
how can I collect npm usage
indexing results for real
terminal on iphone

Tokens indexed
Link to open indexed file
Copy docs to clipboard

include feedback link in installation
Python Advanced AI Agent Tutorial  https://www.youtube.com/watch?v=JLmI0GJuGlY
Firecrawl from Mendable https://docs.firecrawl.dev/api-reference/endpoint/search
Clone llamaindex? 
do i need public scoped package?
package ignore files

select search output
https://github.com/Elius94/console-gui-tools
formatted code output
markdown
if we have docs then we skips crawling
Storage of crawled content
count words in crawled content, sort
Ask to pass a parent link

print 5 empty lines and fill them up
add model output limit
easily copypaste code snippets

codebase context aware
e2b


wrap in a vs code   extension
google search docs
graph kind of thing for related links

chat with docs in VS code: docs on the left, chat on the right
llm playground, no code building blocks and create fully functioning pieces of code, 
notebook experience
chrome extension?

peoblems:
If the condition in the clearConsoleSafely function isn't met, meaning if isPrinting is true, the function will not execute the commands to clear the console line or move the cursor.
npm doesn't track failed installations, find a workaround to track usage

Other tools:
https://www.ycombinator.com/companies/mendable
https://inkeep.com/
swimm.io
kapa.ai Instant AI answers to technical questions
dosubot 

tools to be used in the project:
(puppeteer, selenium, use latest browsers)
e2b

Prompts:
Please provide a summary of the provided content.
















































legacy:

marked.setOptions({
    renderer: new TerminalRenderer()
  });

  async function printTextWithVisualScrollAndFill(text, linesToScroll = 10) {
    const lines = text.split('\n');
    let currentLine = 0;

    while (currentLine < lines.length) {
        // Print empty lines to simulate scrolling down
        console.log('\n'.repeat(linesToScroll));

        // Move cursor up to start filling the lines
        process.stdout.write(ansiEscapes.cursorUp(linesToScroll));

        let linesPrinted = 0;
        for (let i = 0; i < linesToScroll && currentLine < lines.length; i++, currentLine++) {
            await printLineSymbolBySymbol(lines[currentLine]);
            linesPrinted++;
            // Move cursor down only if it's not the last iteration, preparing for the next block
            if (i < linesToScroll - 1 && currentLine < lines.length - 1) {
                process.stdout.write('\n');
            }
        }

        // Adjust cursor position if needed
        if (currentLine < lines.length) {
            let linesRemaining = linesToScroll - linesPrinted;
            if (linesRemaining > 0) {
                // Print empty lines to fill the block
                console.log('\n'.repeat(linesRemaining));
                // Move cursor up to overwrite these lines in the next iteration
                process.stdout.write(ansiEscapes.cursorUp(linesRemaining));
            }
        } else {
            // If it's the end of the text, ensure no extra lines are printed
            process.stdout.write(ansiEscapes.cursorUp(linesToScroll - linesPrinted));
        }
    }
}

async function printLineSymbolBySymbol(line) {
    let renderedLine = marked(line);
    for (let i = 0; i < renderedLine.length; i++) {
        process.stdout.write(renderedLine[i]);
        await new Promise(resolve => setTimeout(resolve, 5)); // Adjust delay as needed for smooth typing effect
    }
}
