import * as openapi_typescript_fetch_dist_cjs_types from 'openapi-typescript-fetch/dist/cjs/types';
import * as fetcher from 'openapi-typescript-fetch';
import { TypedFetch, OpArgType } from 'openapi-typescript-fetch';
import { Run, RunSubmitToolOutputsParams } from 'openai/resources/beta/threads/runs/runs';

/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */
interface paths {
    "/health": {
        /** Health check */
        get: {
            responses: {
                /** Request was successful */
                200: unknown;
                401: components["responses"]["401"];
            };
        };
    };
    "/sandboxes": {
        /** List all running sandboxes */
        get: {
            responses: {
                /** Successfully returned all running sandboxes */
                200: {
                    content: {
                        "application/json": components["schemas"]["RunningSandboxes"][];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        /** Create a sandbox from the template */
        post: {
            responses: {
                /** The sandbox was created successfully */
                201: {
                    content: {
                        "application/json": components["schemas"]["Sandbox"];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["NewSandbox"];
                };
            };
        };
    };
    "/sandboxes/{sandboxID}": {
        /** Kill a sandbox */
        delete: {
            parameters: {
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
            };
            responses: {
                /** The sandbox was killed successfully */
                204: never;
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
    };
    "/sandboxes/{sandboxID}/refreshes": {
        /** Refresh the sandbox extending its time to live */
        post: {
            parameters: {
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
            };
            responses: {
                /** Successfully refreshed the sandbox */
                204: never;
                401: components["responses"]["401"];
                404: components["responses"]["404"];
            };
            requestBody: {
                content: {
                    "application/json": {
                        /** @description Duration for which the sandbox should be kept alive in seconds */
                        duration?: number;
                    };
                };
            };
        };
    };
    "/templates": {
        /** List all templates */
        get: {
            responses: {
                /** Successfully returned all templates */
                200: {
                    content: {
                        "application/json": components["schemas"]["Template"][];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        /** Create a new template */
        post: {
            responses: {
                /** The build was accepted */
                202: {
                    content: {
                        "application/json": components["schemas"]["Template"];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TemplateBuildRequest"];
                };
            };
        };
    };
    "/templates/{templateID}": {
        /** Rebuild an template */
        post: {
            parameters: {
                path: {
                    templateID: components["parameters"]["templateID"];
                };
            };
            responses: {
                /** The build was accepted */
                202: {
                    content: {
                        "application/json": components["schemas"]["Template"];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TemplateBuildRequest"];
                };
            };
        };
        /** Delete a template */
        delete: {
            parameters: {
                path: {
                    templateID: components["parameters"]["templateID"];
                };
            };
            responses: {
                /** The template was deleted successfully */
                204: never;
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
    };
    "/templates/{templateID}/builds/{buildID}": {
        /** Start the build */
        post: {
            parameters: {
                path: {
                    templateID: components["parameters"]["templateID"];
                    buildID: components["parameters"]["buildID"];
                };
            };
            responses: {
                /** The build has started */
                202: unknown;
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
    };
    "/templates/{templateID}/builds/{buildID}/logs": {
        /** Add a build log */
        post: {
            parameters: {
                path: {
                    templateID: components["parameters"]["templateID"];
                    buildID: components["parameters"]["buildID"];
                };
            };
            responses: {
                /** Successfully added log */
                201: unknown;
                401: components["responses"]["401"];
                404: components["responses"]["404"];
            };
            requestBody: {
                content: {
                    "application/json": {
                        /** @description API secret */
                        apiSecret: string;
                        logs: string[];
                    };
                };
            };
        };
    };
    "/templates/{templateID}/builds/{buildID}/status": {
        /** Get template build info */
        get: {
            parameters: {
                path: {
                    templateID: components["parameters"]["templateID"];
                    buildID: components["parameters"]["buildID"];
                };
                query: {
                    /** Index of the starting build log that should be returned with the template */
                    logsOffset?: number;
                };
            };
            responses: {
                /** Successfully returned the template */
                200: {
                    content: {
                        "application/json": components["schemas"]["TemplateBuild"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
    };
}
interface components {
    schemas: {
        SandboxMetadata: {
            [key: string]: string;
        };
        Sandbox: {
            /** @description Identifier of the template from which is the sandbox created */
            templateID: string;
            /** @description Identifier of the sandbox */
            sandboxID: string;
            /** @description Alias of the template */
            alias?: string;
            /** @description Identifier of the client */
            clientID: string;
        };
        RunningSandboxes: {
            /** @description Identifier of the template from which is the sandbox created */
            templateID: string;
            /** @description Alias of the template */
            alias?: string;
            /** @description Identifier of the sandbox */
            sandboxID: string;
            /** @description Identifier of the client */
            clientID: string;
            /**
             * Format: date-time
             * @description Time when the sandbox was started
             */
            startedAt: string;
            /** @description CPU cores for the sandbox */
            cpuCount: number;
            /** @description Memory limit for the sandbox in MB */
            memoryMB: number;
            metadata?: components["schemas"]["SandboxMetadata"];
        };
        NewSandbox: {
            /** @description Identifier of the required template */
            templateID: string;
            metadata?: components["schemas"]["SandboxMetadata"];
        };
        Template: {
            /** @description Identifier of the template */
            templateID: string;
            /** @description Identifier of the last successful build for given template */
            buildID: string;
            /** @description CPU cores for the sandbox */
            cpuCount: number;
            /** @description Memory limit for the sandbox in MB */
            memoryMB: number;
            /** @description Whether the template is public or only accessible by the team */
            public: boolean;
            /** @description Aliases of the template */
            aliases?: string[];
        } & {
            storageGB: unknown;
        };
        TemplateBuildRequest: {
            /** @description Alias of the template */
            alias?: string;
            /** @description Dockerfile for the template */
            dockerfile: string;
            /** @description Start command to execute in the template after the build */
            startCmd?: string;
            /** @description CPU cores for the template */
            cpuCount?: number;
            /** @description Memory limit for the template in MB */
            memoryMB?: number;
        };
        TemplateBuild: {
            /**
             * @description Build logs
             * @default []
             */
            logs: string[];
            /** @description Identifier of the template */
            templateID: string;
            /** @description Identifier of the build */
            buildID: string;
            /**
             * @description Status of the template
             * @enum {string}
             */
            status?: "building" | "ready" | "error";
        } & {
            finished: unknown;
        };
        Error: {
            /**
             * Format: int32
             * @description Error code
             */
            code: number;
            /** @description Error */
            message: string;
        };
    };
    responses: {
        /** Bad request */
        400: {
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** Authentication error */
        401: {
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** Not found */
        404: {
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** Server error */
        500: {
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        templateID: string;
        buildID: string;
        sandboxID: string;
    };
}

declare class APIClient {
    private opts?;
    private client;
    constructor(opts?: {
        secure?: boolean | undefined;
        domain?: string | undefined;
        debug?: boolean | undefined;
    } | undefined);
    get secure(): boolean;
    get domain(): string;
    get debug(): string | boolean | undefined;
    get apiDomain(): string;
    get apiHost(): string;
    get api(): {
        configure: (config: openapi_typescript_fetch_dist_cjs_types.FetchConfig) => void;
        use: (mw: fetcher.Middleware) => number;
        path: <P extends keyof paths>(path: P) => {
            method: <M extends keyof paths[P]>(method: M) => {
                create: openapi_typescript_fetch_dist_cjs_types.CreateFetch<M, paths[P][M]>;
            };
        };
    };
}
type WithAccessToken<T> = (accessToken: string, arg: OpArgType<T>, init?: RequestInit) => ReturnType<TypedFetch<T>>;
declare function withAccessToken<T>(f: TypedFetch<T>): WithAccessToken<T> & {
    Error: typeof f.Error;
};
type WithAPIKey<T> = (apiKey: string, arg: OpArgType<T>, init?: RequestInit) => ReturnType<TypedFetch<T>>;
declare function withAPIKey<T>(f: TypedFetch<T>): WithAPIKey<T> & {
    Error: typeof f.Error;
};

declare const API_HOST: string;
declare const SANDBOX_DOMAIN: string;

declare const codeSnippetService = "codeSnippet";
interface OpenPort {
    state: string;
    ip: string;
    port: number;
}
type ScanOpenedPortsHandler = (ports: OpenPort[]) => Promise<void> | void;

type EnvVars = {
    [key: string]: string;
};

declare const processService = "process";
/**
 * A message from a process.
 */
declare class ProcessMessage {
    readonly line: string;
    /**
     * Unix epoch in nanoseconds
     */
    readonly timestamp: number;
    readonly error: boolean;
    constructor(line: string, 
    /**
     * Unix epoch in nanoseconds
     */
    timestamp: number, error: boolean);
    toString(): string;
}
/**
 * Output from a process.
 */
declare class ProcessOutput {
    private readonly delimiter;
    private readonly messages;
    private _finished;
    private _error;
    private _exitCode?;
    /**
     * Whether the process has errored.
     */
    get error(): boolean;
    /**
     * The exit code of the process.
     */
    get exitCode(): number | undefined;
    /**
     * The stdout from the process.
     */
    get stdout(): string;
    /**
     * The stderr from the process.
     */
    get stderr(): string;
    addStdout(message: ProcessMessage): void;
    addStderr(message: ProcessMessage): void;
    setExitCode(exitCode: number): void;
    private insertByTimestamp;
}
/**
 * A process running in the sandbox.
 */
declare class Process {
    readonly processID: string;
    private readonly sandbox;
    private readonly triggerExit;
    readonly output: ProcessOutput;
    /**
     * @deprecated use .wait() instead
     */
    readonly finished: Promise<ProcessOutput>;
    constructor(processID: string, sandbox: SandboxConnection, triggerExit: () => void, finished: Promise<ProcessOutput>, output: ProcessOutput);
    /**
     * Kills the process.
     */
    kill(): Promise<void>;
    /**
     * Waits for the process to finish.
     *
     * @param timeout Timeout for the process to finish in milliseconds
     */
    wait(timeout?: number): Promise<ProcessOutput>;
    /**
     * Sends data to the process stdin.
     *
     * @param data Data to send
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
     */
    sendStdin(data: string, opts?: CallOpts): Promise<void>;
}
interface ProcessOpts {
    cmd: string;
    onStdout?: (out: ProcessMessage) => Promise<void> | void;
    onStderr?: (out: ProcessMessage) => Promise<void> | void;
    onExit?: (() => Promise<void> | void) | ((exitCode: number) => Promise<void> | void);
    envVars?: EnvVars;
    cwd?: string;
    /** @deprecated Use cwd instead */
    rootDir?: string;
    processID?: string;
    /** Timeout for the process to start in milliseconds */
    timeout?: number;
}
/**
 * Manager for starting and interacting with processes in the sandbox.
 */
interface ProcessManager {
    /**
     * Starts a new process.
     * @param cmd Command to execute
     * @returns New process
     */
    start(cmd: string): Promise<Process>;
    /**
     * Starts a new process.
     * @param opts Process options
     * @returns New process
     */
    start(opts: ProcessOpts): Promise<Process>;
    /**
     * Starts a new process and wait until it finishes.
     * @param cmd Command to execute
     * @returns New process
     */
    startAndWait(cmd: string): Promise<ProcessOutput>;
    /**
     * Starts a new process and wait until it finishes.
     * @param opts Process options
     * @returns New process
     */
    startAndWait(opts: ProcessOpts): Promise<ProcessOutput>;
}

declare const terminalService = "terminal";
declare class TerminalOutput {
    private _data;
    get data(): string;
    addData(data: string): void;
}
/**
 * A terminal session running in the sandbox.
 *
 */
declare class Terminal {
    readonly terminalID: string;
    private readonly sandbox;
    private readonly triggerExit;
    readonly output: TerminalOutput;
    /**
     * @deprecated use .wait() instead
     */
    readonly finished: Promise<TerminalOutput>;
    constructor(terminalID: string, sandbox: SandboxConnection, triggerExit: () => void, finished: Promise<TerminalOutput>, output: TerminalOutput);
    get data(): string;
    /**
     * Kills the terminal session.
     */
    kill(): Promise<void>;
    /**
     * Waits for the terminal to finish.
     */
    wait(): Promise<TerminalOutput>;
    /**
     * Sends data to the terminal standard input.
     *
     * @param data Data to send
     */
    sendData(data: string): Promise<void>;
    /**
     * Resizes the terminal tty.
     *
     * @param cols Number of columns
     * @param rows Number of rows
     */
    resize({ cols, rows }: {
        cols: number;
        rows: number;
    }): Promise<void>;
}
type TerminalOpts = {
    onData: (data: string) => Promise<void> | void;
    onExit?: () => Promise<void> | void;
    size: {
        cols: number;
        rows: number;
    };
    terminalID?: string;
    /**
     * If the `cmd` parameter is defined it will be executed as a command
     * and this terminal session will exit when the command exits.
     */
    cmd?: string;
    /**
     * Working directory where will the terminal start.
     */
    cwd?: string;
    /**
     * @deprecated use cwd instead
     */
    rootDir?: string;
    /**
     * Environment variables that will be accessible inside of the terminal.
     */
    envVars?: EnvVars;
    /**
     * Timeout for terminal start in milliseconds (default is 60 seconds)
     */
    timeout?: number;
};
/**
 * Manager for starting and interacting with terminal sessions in the sandbox.
 */
interface TerminalManager {
    start(opts: TerminalOpts): Promise<Terminal>;
}

type SubscriptionHandler = (result: any) => void;
type Service = typeof processService | typeof codeSnippetService | typeof filesystemService | typeof terminalService;
interface Logger {
    debug?: (message: string, ...args: unknown[]) => void;
    info?: (message: string, ...args: unknown[]) => void;
    warn?: (message: string, ...args: unknown[]) => void;
    error?: (message: string, ...args: unknown[]) => void;
}
interface SandboxMetadata {
    [key: string]: string;
}
interface RunningSandbox {
    sandboxID: string;
    templateID: string;
    alias?: string;
    metadata?: SandboxMetadata;
    startedAt: Date;
}
interface SandboxConnectionOpts {
    /**
     * Sandbox Template ID or name.
     *
     * If not specified, the 'base' template will be used.
     */
    template?: string;
    /**
     * @deprecated Use `template` instead.
     *
     * Sandbox Template ID or name.
     */
    id?: string;
    apiKey?: string;
    /**
     * Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.
     */
    domain?: string;
    cwd?: string;
    envVars?: EnvVars;
    /**
     * A dictionary of strings that is stored alongside the running sandbox.
     * You can see this metadata when you list running sandboxes.
     */
    metadata?: SandboxMetadata;
    logger?: Logger;
    __sandbox?: components['schemas']['Sandbox'];
    __debug_hostname?: string;
    __debug_port?: number;
    __debug_devEnv?: 'remote' | 'local';
}
interface CallOpts {
    /** Timeout for the call in milliseconds */
    timeout?: number;
}
declare class SandboxConnection {
    readonly opts: SandboxConnectionOpts;
    /**
     * Default working directory used in the sandbox.
     *
     * You can change the working directory by setting the `cwd` property.
     **/
    cwd: string | undefined;
    /**
     * Default environment variables used in the sandbox.
     *
     * You can change the environment variables by setting the `envVars` property.
     **/
    envVars: EnvVars;
    protected readonly logger: Logger;
    protected sandbox?: components['schemas']['Sandbox'];
    protected isOpen: boolean;
    private readonly apiKey;
    private readonly rpc;
    private subscribers;
    private readonly client;
    protected constructor(opts: SandboxConnectionOpts);
    /**
     * ID of the sandbox.
     *
     * You can use this ID to reconnect to the sandbox later.
     */
    get id(): string;
    private get templateID();
    private get refreshSandbox();
    private get createSandbox();
    /**
     * List all running sandboxes
     *
     * @param apiKey API key to use for authentication. If not provided, the `E2B_API_KEY` environment variable will be used.
     * @param domain Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.
     */
    static list(apiKey?: string, domain?: string): Promise<RunningSandbox[]>;
    /**
     * List all running sandboxes
     * @param sandboxID ID of the sandbox to kill
     * @param apiKey API key to use for authentication. If not provided, the `E2B_API_KEY` environment variable will be used.
     * @param domain Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.
     */
    static kill(sandboxID: string, apiKey?: string, domain?: string): Promise<void>;
    /**
     * Keep the sandbox alive for the specified duration.
     *
     * `keepAlive` method requires `this` context - you may need to bind it.
     * @param duration Duration in milliseconds. Must be between 0 and 3600000 milliseconds
     * @returns Promise that resolves when the sandbox is kept alive
     */
    keepAlive(duration: number): Promise<void>;
    /**
     * Get the hostname for the sandbox or for the specified sandbox's port.
     *
     * `getHostname` method requires `this` context - you may need to bind it.
     *
     * @param port Specify if you want to connect to a specific port of the sandbox
     * @returns Hostname of the sandbox or sandbox's port
     */
    getHostname(port?: number): string;
    /**
     * The function decides whether to use the secure or insecure protocol.
     * @param baseProtocol Specify the specific protocol you want to use. Do not include the `s` in `https` or `wss`.
     * @param secure Specify if you want to use the secure protocol
     * @returns Protocol for the connection to the sandbox
     */
    getProtocol(baseProtocol?: string, secure?: boolean): string;
    /**
     * Close the connection to the sandbox
     *
     * `close` method requires `this` context - you may need to bind it.
     */
    close(): Promise<void>;
    _call(service: Service, method: string, params?: any[], opts?: CallOpts): Promise<unknown>;
    _handleSubscriptions<T extends (ReturnType<SandboxConnection['_subscribe']> | undefined)[]>(...subs: T): Promise<{
        [P in keyof T]: Awaited<T[P]>;
    }>;
    _unsubscribe(subID: string): Promise<void>;
    _subscribe(service: Service, handler: SubscriptionHandler, method: string, ...params: any[]): Promise<string>;
    /**
     * Open a connection to a new sandbox
     *
     * `open` method requires `this` context - you may need to bind it.
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for sandbox to open in milliseconds (default is 60 seconds)
     */
    protected _open(opts: CallOpts): Promise<this>;
    private connectRpc;
    private handleNotification;
    private refresh;
}

declare enum FilesystemOperation {
    Create = "Create",
    Write = "Write",
    Remove = "Remove",
    Rename = "Rename",
    Chmod = "Chmod"
}
interface FilesystemEvent {
    path: string;
    name: string;
    operation: FilesystemOperation;
    timestamp: number;
    isDir: boolean;
}
type FilesystemEventListener = (event: FilesystemEvent) => Promise<void> | void;
declare class FilesystemWatcher {
    private sessConn;
    private path;
    private listeners;
    private rpcSubscriptionID?;
    constructor(sessConn: SandboxConnection, path: string);
    start(opts?: CallOpts): Promise<void>;
    stop(): Promise<void>;
    addEventListener(l: FilesystemEventListener): () => boolean;
    private handleFilesystemEvents;
}

declare const filesystemService = "filesystem";
interface FileInfo {
    isDir: boolean;
    name: string;
}
/**
 * Manager for interacting with the filesystem in the sandbox.
 */
interface FilesystemManager {
    /**
     * Writes content to a new file on path.
     * @param path Path to a new file. For example '/dirA/dirB/newFile.txt' when creating 'newFile.txt'
     * @param content Content to write to a new file
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
     */
    write(path: string, content: string, opts?: CallOpts): Promise<void>;
    /**
     * Write array of bytes to a file.
     * This can be used when you cannot represent the data as an UTF-8 string.
     *
     * A new file will be created if it doesn't exist.
     * If the file already exists, it will be overwritten.
     *
     * @param path path to a file
     * @param content byte array representing the content to write
     */
    writeBytes(path: string, content: Uint8Array): Promise<void>;
    /**
     * Reads the whole content of a file.
     * @param path Path to a file
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
     * @returns Content of a file
     */
    read(path: string, opts?: CallOpts): Promise<string>;
    /**
     * Reads the whole content of a file as an array of bytes.
     * @param path path to a file
     * @returns byte array representing the content of a file
     */
    readBytes(path: string): Promise<Uint8Array>;
    /**
     * Removes a file or a directory.
     * @param path Path to a file or a directory
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
     */
    remove(path: string, opts?: CallOpts): Promise<void>;
    /**
     * List files in a directory.
     * @param path Path to a directory
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
     * @returns Array of files in a directory
     */
    list(path: string, opts?: CallOpts): Promise<FileInfo[]>;
    /**
     * Creates a new directory and all directories along the way if needed on the specified pth.
     * @param path Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
     * @param opts Call options
     * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
     */
    makeDir(path: string, opts?: CallOpts): Promise<void>;
    /**
     * Watches directory for filesystem events.
     * @param path Path to a directory that will be watched
     * @returns New watcher
     */
    watchDir(path: string): FilesystemWatcher;
}

declare class Actions {
    private readonly sandbox;
    constructor(sandbox: Sandbox);
    /**
     * Call the required actions for the provided run and return their outputs.
     *
     * @param run OpenAI run object from `openai.beta.threads.runs.retrieve` or `openai.beta.threads.runs.retrieve.create` call that contains the names of the required actions and their arguments.
     * @returns The outputs of the required actions in the run.
     */
    run(run: Run): Promise<RunSubmitToolOutputsParams.ToolOutput[]>;
}

type DownloadFileFormat = 'base64' | 'blob' | 'buffer' | 'arraybuffer' | 'text';
interface SandboxOpts extends SandboxConnectionOpts {
    onScanPorts?: ScanOpenedPortsHandler;
    /** Timeout for sandbox to start */
    timeout?: number;
    onStdout?: (out: ProcessMessage) => Promise<void> | void;
    onStderr?: (out: ProcessMessage) => Promise<void> | void;
    onExit?: (() => Promise<void> | void) | ((exitCode: number) => Promise<void> | void);
}
interface Action<S extends Sandbox = Sandbox, T = {
    [key: string]: any;
}> {
    (sandbox: S, args: T): string | Promise<string>;
}
/**
 * E2B cloud sandbox gives your agent a full cloud development environment that's sandboxed.
 *
 * That means:
 * - Access to Linux OS
 * - Using filesystem (create, list, and delete files and dirs)
 * - Run processes
 * - Sandboxed - you can run any code
 * - Access to the internet
 *
 * Check usage docs - https://e2b.dev/docs/sandbox/overview
 *
 * These cloud sandboxes are meant to be used for agents. Like a sandboxed playgrounds, where the agent can do whatever it wants.
 *
 * Use the {@link Sandbox.create} method to create a new sandbox.
 *
 * @example
 * ```ts
 * import { Sandbox } from '@e2b/sdk'
 *
 * const sandbox = await Sandbox.create()
 *
 * await sandbox.close()
 * ```
 */
declare class Sandbox extends SandboxConnection {
    /**
     * Terminal manager used to create interactive terminals.
     */
    readonly terminal: TerminalManager;
    /**
     * Filesystem manager used to manage files.
     */
    readonly filesystem: FilesystemManager;
    /**
     * Process manager used to run commands.
     */
    readonly process: ProcessManager;
    readonly _actions: Map<string, Action<any, any>>;
    private readonly onScanPorts?;
    /**
     * Use `Sandbox.create()` instead.
     *
     * @hidden
     * @hide
     * @internal
     * @access protected
     */
    constructor(opts?: SandboxOpts);
    /**
     * URL that can be used to download or upload file to the sandbox via a multipart/form-data POST request.
     * This is useful if you're uploading files directly from the browser.
     * The file will be uploaded to the user's home directory with the same name.
     * If a file with the same name already exists, it will be overwritten.
     */
    get fileURL(): string;
    /**
     * Returns a map of added actions.
     *
     * @returns Map of added actions
     */
    get actions(): Map<string, Action<any, any>>;
    /**
     * OpenAI integration that can be used to get output for the actions added in the sandbox.
     *
     * @returns OpenAI integration
     */
    get openai(): {
        readonly actions: Actions;
    };
    /**
     * Creates a new Sandbox from the default `base` sandbox template.
     * @returns New Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * ```
     * @constructs Sandbox
     */
    static create<S extends typeof Sandbox>(this: S): Promise<InstanceType<S>>;
    /**
     * Creates a new Sandbox from the template with the specified ID.
     * @param template Sandbox template ID or name
     * @returns New Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create("sandboxTemplateID")
     * ```
     */
    static create<S extends typeof Sandbox>(this: S, template: string): Promise<InstanceType<S>>;
    /**
     * Creates a new Sandbox from the specified options.
     * @param opts Sandbox options
     * @returns New Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create({
     *   template: "sandboxTemplate",
     *   onStdout: console.log,
     * })
     * ```
     */
    static create<S extends typeof Sandbox>(this: S, opts: SandboxOpts): Promise<InstanceType<S>>;
    /**
     * Reconnects to an existing Sandbox.
     * @param sandboxID Sandbox ID
     * @returns Existing Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * const sandboxID = sandbox.id
     *
     * await sandbox.keepAlive(300 * 1000)
     * await sandbox.close()
     *
     * const reconnectedSandbox = await Sandbox.reconnect(sandboxID)
     * ```
     */
    static reconnect<S extends typeof Sandbox>(this: S, sandboxID: string): Promise<InstanceType<S>>;
    /**
     * Reconnects to an existing Sandbox.
     * @param opts Sandbox options
     * @returns Existing Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * const sandboxID = sandbox.id
     *
     * await sandbox.keepAlive(300 * 1000)
     * await sandbox.close()
     *
     * const reconnectedSandbox = await Sandbox.reconnect({
     *   sandboxID,
     * })
     * ```
     */
    static reconnect<S extends typeof Sandbox>(this: S, opts: Omit<SandboxOpts, 'id' | 'template'> & {
        sandboxID: string;
    }): Promise<InstanceType<S>>;
    /**
     * Add a new action. The name of the action is automatically extracted from the function name.
     *
     * You can use this action with specific integrations like OpenAI to interact with the sandbox and get output for the action.
     *
     * @param action Action handler
     * @returns Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * sandbox.addAction('readFile', (sandbox, args) => sandbox.filesystem.read(args.path))
     * ```
     */
    addAction<T = {
        [name: string]: any;
    }>(action: Action<this, T>): this;
    /**
     * Add a new action with a specified name.
     *
     * You can use this action with specific integrations like OpenAI to interact with the sandbox and get output for the action.
     *
     * @param name Action name
     * @param action Action handler
     * @returns Sandbox
     *
     * @example
     * ```ts
     * async function readFile(sandbox: Sandbox, args: any) {
     *   return sandbox.filesystem.read(args.path)
     * }
     *
     * const sandbox = await Sandbox.create()
     * sandbox.addAction(readFile)
     * ```
     */
    addAction<T = {
        [name: string]: any;
    }>(name: string, action: Action<this, T>): this;
    /**
     * Remove an action.
     * @param name Action name
     * @returns Sandbox
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * sandbox.addAction('hello', (sandbox, args) => 'Hello World')
     * sandbox.removeAction('hello')
     * ```
     */
    removeAction(name: string): this;
    /**
     * Uploads a file to the sandbox.
     * The file will be uploaded to the user's home directory with the same name.
     * If a file with the same name already exists, it will be overwritten.
     *
     * **You can use the {@link Sandbox.fileURL} property and upload file directly via POST multipart/form-data**
     *
     */
    uploadFile(file: Buffer | Blob, filename: string): Promise<string>;
    /**
     * Downloads a file from the sandbox.
     * @param remotePath Path to a file on the sandbox
     * @param format Format of the downloaded file
     * @returns File content
     *
     * @example
     * ```ts
     * const sandbox = await Sandbox.create()
     * const content = await sandbox.downloadFile('/home/user/file.txt')
     * ```
     */
    downloadFile(remotePath: string, format?: DownloadFileFormat): Promise<string | Blob | ArrayBuffer>;
    protected _open(opts: CallOpts): Promise<this>;
    private handleStartCmdLogs;
}

declare class TimeoutError extends Error {
    constructor(message: any);
}
declare class AuthenticationError extends Error {
    constructor(message: any);
}
declare class CurrentWorkingDirectoryDoesntExistError extends Error {
    constructor(message: any);
}

declare enum CodeRuntime {
    Node16 = "Node16",
    Python3 = "Python3",
    Bash = "Bash",
    Python3_DataAnalysis = "Python3-DataAnalysis"
}
/**
 * Run code in a sandboxed cloud playground.
 * `runCode` wraps the `Sandbox` class and provides a simple interface for running code in a sandboxed environment
 * without any need to manage lifecycle of the sandbox.
 * `runCode` automatically loads the E2B API key from the `E2B_API_KEY` environment variable.
 *
 * @param runtime The runtime to use when running the code. Can be one of the following:
 * - "Node16"
 * - "Python3"
 *
 * **Let us know if you need support for other runtimes.**
 * @param code The code to run
 * @param opts Optional parameters to pass
 * @returns
 */
declare function runCode(runtime: CodeRuntime, code: string, opts?: {
    apiKey?: string;
}): Promise<{
    stdout: string;
    stderr: string;
}>;

declare class Artifact<S extends DataAnalysis> {
    readonly path: string;
    readonly _sandbox: S;
    constructor(path: string, sandbox: S);
    download(): Promise<string | Blob | ArrayBuffer>;
}
interface RunPythonOpts<S extends DataAnalysis> extends Omit<ProcessOpts, 'cmd'> {
    onArtifact?: (artifact: Artifact<S>) => Promise<void> | void;
}
declare class DataAnalysis extends Sandbox {
    private static template;
    /**
     * Use `DataAnalysis.create()` instead.
     *
     * @hidden
     * @hide
     * @internal
     * @access protected
     */
    constructor(opts: SandboxOpts);
    /**
     * Creates a new Sandbox from the template.
     * @returns New Sandbox
     */
    static create(): Promise<DataAnalysis>;
    /**
     * Creates a new Sandbox from the specified options.
     * @param opts Sandbox options
     * @returns New Sandbox
     */
    static create(opts: SandboxOpts): Promise<DataAnalysis>;
    runPython(code: string, opts?: RunPythonOpts<this>): Promise<{
        stdout: string;
        stderr: string;
        artifacts: Artifact<DataAnalysis>[];
    }>;
    installPythonPackages(packageNames: string | string[]): Promise<void>;
    installSystemPackages(packageNames: string | string[]): Promise<void>;
    private installPackages;
}

export { APIClient, API_HOST, Action, Artifact, AuthenticationError, DataAnalysis as CodeInterpreter, CodeRuntime, CurrentWorkingDirectoryDoesntExistError, DataAnalysis, DownloadFileFormat, EnvVars, FileInfo, FilesystemEvent, FilesystemEventListener, FilesystemManager, FilesystemOperation, FilesystemWatcher, OpenPort, Process, ProcessManager, ProcessMessage, ProcessOutput, RunPythonOpts, RunningSandbox, SANDBOX_DOMAIN, Sandbox, SandboxMetadata, SandboxOpts, Terminal, TerminalManager, TerminalOutput, TimeoutError, components, Sandbox as default, paths, runCode, withAPIKey, withAccessToken };
