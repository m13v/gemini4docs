"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  APIClient: () => APIClient,
  API_HOST: () => API_HOST,
  Artifact: () => Artifact,
  AuthenticationError: () => AuthenticationError,
  CodeInterpreter: () => DataAnalysis,
  CodeRuntime: () => CodeRuntime,
  CurrentWorkingDirectoryDoesntExistError: () => CurrentWorkingDirectoryDoesntExistError,
  DataAnalysis: () => DataAnalysis,
  FilesystemOperation: () => FilesystemOperation,
  FilesystemWatcher: () => filesystemWatcher_default,
  Process: () => Process,
  ProcessMessage: () => ProcessMessage,
  ProcessOutput: () => ProcessOutput,
  SANDBOX_DOMAIN: () => SANDBOX_DOMAIN,
  Sandbox: () => Sandbox,
  Terminal: () => Terminal,
  TerminalOutput: () => TerminalOutput,
  TimeoutError: () => TimeoutError2,
  default: () => src_default,
  runCode: () => runCode,
  withAPIKey: () => withAPIKey,
  withAccessToken: () => withAccessToken
});
module.exports = __toCommonJS(src_exports);

// src/api/index.ts
var fetcher = __toESM(require("openapi-typescript-fetch"));

// src/api/metadata.ts
var import_platform = __toESM(require("platform"));

// package.json
var version = "0.13.2";

// src/api/metadata.ts
var _a;
var defaultHeaders = {
  browser: typeof window !== "undefined" && import_platform.default.name || "undefined",
  lang: "js",
  lang_version: import_platform.default.version || "unknown",
  package_version: version,
  publisher: "e2b",
  sdk_runtime: typeof window === "undefined" ? "node" : "browser",
  system: ((_a = import_platform.default.os) == null ? void 0 : _a.family) || "unknown"
};

// src/constants.ts
var SANDBOX_REFRESH_PERIOD = 5e3;
var WS_RECONNECT_INTERVAL = 150;
var TIMEOUT = 6e4;
var _a2;
var DEBUG = (_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2.E2B_DEBUG;
var _a3;
var DOMAIN = ((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3.E2B_DOMAIN) || "e2b.dev";
var _a4;
var SECURE = (((_a4 = process == null ? void 0 : process.env) == null ? void 0 : _a4.E2B_SECURE) || "true").toLowerCase() === "true";
var API_DOMAIN = DEBUG ? "localhost:3000" : `api.${DOMAIN}`;
var API_HOST = `${SECURE && !DEBUG ? "https" : "http"}://${API_DOMAIN}`;
var SANDBOX_DOMAIN = DOMAIN;
var ENVD_PORT = 49982;
var WS_ROUTE = "/ws";
var FILE_ROUTE = "/file";

// src/api/index.ts
var { Fetcher } = fetcher;
var APIClient = class {
  constructor(opts) {
    this.opts = opts;
    this.client = Fetcher.for();
    this.client.configure({
      baseUrl: this.apiHost,
      init: {
        headers: defaultHeaders
      }
    });
  }
  get secure() {
    var _a5, _b;
    return (_b = (_a5 = this.opts) == null ? void 0 : _a5.secure) != null ? _b : SECURE;
  }
  get domain() {
    var _a5, _b;
    return (_b = (_a5 = this.opts) == null ? void 0 : _a5.domain) != null ? _b : DOMAIN;
  }
  get debug() {
    var _a5, _b;
    return (_b = (_a5 = this.opts) == null ? void 0 : _a5.debug) != null ? _b : DEBUG;
  }
  get apiDomain() {
    return this.debug ? "localhost:3000" : `api.${this.domain}`;
  }
  get apiHost() {
    return `${this.secure && !this.debug ? "https" : "http"}://${this.apiDomain}`;
  }
  get api() {
    return this.client;
  }
};
function withAccessToken(f) {
  const wrapped = (accessToken, arg, init) => {
    return f(arg, __spreadProps(__spreadValues({}, init), {
      headers: __spreadValues({
        Authorization: `Bearer ${accessToken}`
      }, init == null ? void 0 : init.headers)
    }));
  };
  wrapped.Error = f.Error;
  return wrapped;
}
function withAPIKey(f) {
  const wrapped = (apiKey, arg, init) => {
    return f(arg, __spreadProps(__spreadValues({}, init), {
      headers: __spreadValues({
        "X-API-KEY": apiKey
      }, init == null ? void 0 : init.headers)
    }));
  };
  wrapped.Error = f.Error;
  return wrapped;
}

// src/sandbox/terminal.ts
var terminalService = "terminal";
var TerminalOutput = class {
  constructor() {
    this._data = "";
  }
  get data() {
    return this._data;
  }
  addData(data) {
    this._data += data;
  }
};
var Terminal = class {
  constructor(terminalID, sandbox, triggerExit, finished, output) {
    this.terminalID = terminalID;
    this.sandbox = sandbox;
    this.triggerExit = triggerExit;
    this.output = output;
    this.finished = finished;
  }
  get data() {
    return this.output.data;
  }
  /**
   * Kills the terminal session.
   */
  kill() {
    return __async(this, null, function* () {
      try {
        yield this.sandbox._call(terminalService, "destroy", [this.terminalID]);
      } finally {
        this.triggerExit();
        yield this.finished;
      }
    });
  }
  /**
   * Waits for the terminal to finish.
   */
  wait() {
    return __async(this, null, function* () {
      return this.finished;
    });
  }
  /**
   * Sends data to the terminal standard input.
   *
   * @param data Data to send
   */
  sendData(data) {
    return __async(this, null, function* () {
      yield this.sandbox._call(terminalService, "data", [this.terminalID, data]);
    });
  }
  /**
   * Resizes the terminal tty.
   *
   * @param cols Number of columns
   * @param rows Number of rows
   */
  resize(_0) {
    return __async(this, arguments, function* ({ cols, rows }) {
      yield this.sandbox._call(terminalService, "resize", [
        this.terminalID,
        cols,
        rows
      ]);
    });
  }
};

// src/utils/timeout.js
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message != null ? message : `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (() => __async(this, null, function* () {
      try {
        resolve(yield promise);
      } catch (error) {
        reject(error);
      }
    }))();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// src/utils/promise.ts
function assertFulfilled(item) {
  return item.status === "fulfilled";
}
function formatSettledErrors(settled) {
  if (settled.every((s) => s.status === "fulfilled"))
    return;
  return settled.reduce((prev, curr, i) => {
    if (curr.status === "rejected") {
      return prev + `
[${i}]: ${JSON.stringify(curr)}`;
    }
    return prev;
  }, "errors:\n");
}
function createDeferredPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    reject,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    resolve
  };
}
function withTimeout(fn, timeout = TIMEOUT) {
  if (timeout === void 0 || timeout <= 0 || timeout === Number.POSITIVE_INFINITY) {
    return fn;
  }
  return (...args) => pTimeout(fn(...args), { milliseconds: timeout });
}

// src/sandbox/filesystem.ts
var filesystemService = "filesystem";

// src/sandbox/filesystemWatcher.ts
var FilesystemOperation = /* @__PURE__ */ ((FilesystemOperation2) => {
  FilesystemOperation2["Create"] = "Create";
  FilesystemOperation2["Write"] = "Write";
  FilesystemOperation2["Remove"] = "Remove";
  FilesystemOperation2["Rename"] = "Rename";
  FilesystemOperation2["Chmod"] = "Chmod";
  return FilesystemOperation2;
})(FilesystemOperation || {});
var FilesystemWatcher = class {
  constructor(sessConn, path2) {
    this.sessConn = sessConn;
    this.path = path2;
    this.listeners = /* @__PURE__ */ new Set();
  }
  // Starts watching the path that was passed to the contructor
  start(opts) {
    return __async(this, null, function* () {
      const start = () => __async(this, null, function* () {
        if (this.rpcSubscriptionID)
          return;
        this.handleFilesystemEvents = this.handleFilesystemEvents.bind(this);
        this.rpcSubscriptionID = yield this.sessConn._subscribe(
          filesystemService,
          this.handleFilesystemEvents,
          "watchDir",
          this.path
        );
      });
      return yield withTimeout(start, opts == null ? void 0 : opts.timeout)();
    });
  }
  // Stops watching the path and removes all listeners.
  stop() {
    return __async(this, null, function* () {
      this.listeners.clear();
      if (this.rpcSubscriptionID) {
        yield this.sessConn._unsubscribe(this.rpcSubscriptionID);
      }
    });
  }
  addEventListener(l) {
    this.listeners.add(l);
    return () => this.listeners.delete(l);
  }
  handleFilesystemEvents(fsChange) {
    this.listeners.forEach((l) => {
      l(fsChange);
    });
  }
};
var filesystemWatcher_default = FilesystemWatcher;

// src/error.ts
var TimeoutError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AuthenticationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AuthenticationError";
  }
};
var CurrentWorkingDirectoryDoesntExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CurrentWorkingDirectoryDoesntExistError";
  }
};

// src/sandbox/process.ts
var processService = "process";
var ProcessMessage = class {
  constructor(line, timestamp, error) {
    this.line = line;
    this.timestamp = timestamp;
    this.error = error;
  }
  toString() {
    return this.line;
  }
};
var ProcessOutput = class {
  constructor() {
    this.delimiter = "\n";
    this.messages = [];
    this._finished = false;
    this._error = false;
  }
  /**
   * Whether the process has errored.
   */
  get error() {
    return this._error;
  }
  /**
   * The exit code of the process.
   */
  get exitCode() {
    if (!this._finished) {
      throw new Error("Process has not finished yet");
    }
    return this._exitCode;
  }
  /**
   * The stdout from the process.
   */
  get stdout() {
    return this.messages.filter((out) => !out.error).map((out) => out.line).join(this.delimiter);
  }
  /**
   * The stderr from the process.
   */
  get stderr() {
    return this.messages.filter((out) => out.error).map((out) => out.line).join(this.delimiter);
  }
  addStdout(message) {
    this.insertByTimestamp(message);
  }
  addStderr(message) {
    this._error = true;
    this.insertByTimestamp(message);
  }
  setExitCode(exitCode) {
    this._exitCode = exitCode;
    this._finished = true;
  }
  insertByTimestamp(message) {
    let i = this.messages.length - 1;
    while (i >= 0 && this.messages[i].timestamp > message.timestamp) {
      i -= 1;
    }
    this.messages.splice(i + 1, 0, message);
  }
};
var Process = class {
  constructor(processID, sandbox, triggerExit, finished, output) {
    this.processID = processID;
    this.sandbox = sandbox;
    this.triggerExit = triggerExit;
    this.output = output;
    this.finished = finished;
  }
  /**
   * Kills the process.
   */
  kill() {
    return __async(this, null, function* () {
      try {
        yield this.sandbox._call(processService, "kill", [this.processID]);
      } finally {
        this.triggerExit();
        yield this.finished;
      }
    });
  }
  /**
   * Waits for the process to finish.
   *
   * @param timeout Timeout for the process to finish in milliseconds
   */
  wait(timeout) {
    return __async(this, null, function* () {
      return yield withTimeout(() => this.finished, timeout)();
    });
  }
  /**
   * Sends data to the process stdin.
   *
   * @param data Data to send
   * @param opts Call options
   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
   */
  sendStdin(data, opts) {
    return __async(this, null, function* () {
      yield this.sandbox._call(
        processService,
        "stdin",
        [this.processID, data],
        opts
      );
    });
  }
};

// src/sandbox/index.ts
var import_normalize_path = __toESM(require("normalize-path"));

// src/utils/id.ts
function id(length) {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

// src/sandbox/codeSnippet.ts
var codeSnippetService = "codeSnippet";

// src/sandbox/rpc.ts
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var RpcWebSocketClient = class {
  // constructor
  /**
   * Does not start WebSocket connection!
   * You need to call connect() method first.
   * @memberof RpcWebSocketClient
   */
  constructor() {
    this.onOpenHandlers = [];
    this.onAnyMessageHandlers = [];
    this.onNotification = [];
    this.onRequest = [];
    this.onSuccessResponse = [];
    this.onErrorResponse = [];
    this.onErrorHandlers = [];
    this.onCloseHandlers = [];
    this.config = {
      responseTimeout: 1e4
    };
    this.idAwaiter = {};
    this.ws = void 0;
  }
  // public
  /**
   * Starts WebSocket connection. Returns Promise when connection is established.
   * @param {string} url
   * @param {(string | string[])} [protocols]
   * @memberof RpcWebSocketClient
   */
  connect(url, protocols) {
    this.ws = new import_isomorphic_ws.default(url, protocols);
    return this.listen();
  }
  // events
  onOpen(fn) {
    this.onOpenHandlers.push(fn);
  }
  /**
   * Native onMessage event. DO NOT USE THIS unless you really have to or for debugging purposes.
   * Proper RPC events are onRequest, onNotification, onSuccessResponse and onErrorResponse (or just awaiting response).
   * @param {RpcMessageEventFunction} fn
   * @memberof RpcWebSocketClient
   */
  onAnyMessage(fn) {
    this.onAnyMessageHandlers.push(fn);
  }
  onError(fn) {
    this.onErrorHandlers.push(fn);
  }
  onClose(fn) {
    this.onCloseHandlers.push(fn);
  }
  /**
   * Appends onmessage listener on native websocket with RPC handlers.
   * If onmessage function was already there, it will call it on beggining.
   * Useful if you want to use RPC WebSocket Client on already established WebSocket along with function changeSocket().
   * @memberof RpcWebSocketClient
   */
  listenMessages() {
    let previousOnMessage;
    if (this.ws.onmessage) {
      previousOnMessage = this.ws.onmessage.bind(this.ws);
    }
    this.ws.onmessage = (e) => {
      if (previousOnMessage) {
        previousOnMessage(e);
      }
      for (const handler of this.onAnyMessageHandlers) {
        handler(e);
      }
      const data = JSON.parse(e.data.toString());
      if (this.isNotification(data)) {
        for (const handler of this.onNotification) {
          handler(data);
        }
      } else if (this.isRequest(data)) {
        for (const handler of this.onRequest) {
          handler(data);
        }
      } else if (this.isSuccessResponse(data)) {
        for (const handler of this.onSuccessResponse) {
          handler(data);
        }
        this.idAwaiter[data.id](data.result);
      } else if (this.isErrorResponse(data)) {
        for (const handler of this.onErrorResponse) {
          handler(data);
        }
        this.idAwaiter[data.id](data.error);
      }
    };
  }
  // communication
  /**
   * Creates and sends RPC request. Resolves when appropirate response is returned from server or after config.responseTimeout.
   * @param {string} method
   * @param {*} [params]
   * @returns
   * @memberof RpcWebSocketClient
   */
  call(method, params) {
    return new Promise((resolve, reject) => {
      const data = this.buildRequest(method, params);
      let timeout;
      if (this.config.responseTimeout) {
        timeout = setTimeout(() => {
          delete this.idAwaiter[data.id];
          reject(
            new Error(`Awaiting response to "${method}" with id: ${data.id} timed out.`)
          );
        }, this.config.responseTimeout);
      }
      this.idAwaiter[data.id] = (responseData) => {
        clearInterval(timeout);
        delete this.idAwaiter[data.id];
        if (this.isRpcError(responseData)) {
          reject(new Error(`RPC Error (${responseData.code}): ${responseData.message}`));
          return;
        }
        resolve(responseData);
      };
      const json = JSON.stringify(data);
      this.ws.send(json);
    });
  }
  /**
   * Creates and sends RPC Notification.
   * @param {string} method
   * @param {*} [params]
   * @memberof RpcWebSocketClient
   */
  notify(method, params) {
    this.ws.send(JSON.stringify(this.buildNotification(method, params)));
  }
  // setup
  /**
   * You can provide custom id generation function to replace default uuid/v1.
   * @param {() => string} idFn
   * @memberof RpcWebSocketClient
   */
  customId(idFn) {
    this.idFn = idFn;
  }
  /**
   * Removed jsonrpc from sent messages. Good if you don't care about standards or need better performance.
   * @memberof RpcWebSocketClient
   */
  noRpc() {
    this.buildRequest = this.buildRequestBase;
    this.buildNotification = this.buildNotificationBase;
    this.buildRpcSuccessResponse = this.buildRpcSuccessResponseBase;
    this.buildRpcErrorResponse = this.buildRpcErrorResponseBase;
  }
  /**
   * Allows modifying configuration.
   * @param {IRpcWebSocketConfig} options
   * @memberof RpcWebSocketClient
   */
  configure(options) {
    Object.assign(this.config, options);
  }
  /**
   * Allows you to change used native WebSocket client to another one.
   * If you have already-connected WebSocket, use this with listenMessages().
   * @param {WebSocket} ws
   * @memberof RpcWebSocketClient
   */
  changeSocket(ws) {
    this.ws = ws;
  }
  // private
  // events
  listen() {
    return new Promise((resolve, reject) => {
      this.ws.onopen = (e) => {
        for (const handler of this.onOpenHandlers) {
          handler(e);
        }
        resolve(e);
      };
      this.listenMessages();
      this.ws.onerror = (e) => {
        for (const handler of this.onErrorHandlers) {
          handler(e);
        }
      };
      this.ws.onclose = (e) => {
        for (const handler of this.onCloseHandlers) {
          handler(e);
        }
        reject(new Error(`WebSocket closed with code: ${e.code} and reason: ${e.reason}`));
      };
    });
  }
  // request
  buildRequest(method, params) {
    const data = this.buildRequestBase(method, params);
    data.jsonrpc = "2.0" /* RPC_VERSION */;
    return data;
  }
  buildRequestBase(method, params) {
    const data = {};
    data.id = this.idFn();
    data.method = method;
    if (params) {
      data.params = params;
    }
    return data;
  }
  // notification
  buildNotification(method, params) {
    const data = this.buildNotificationBase(method, params);
    data.jsonrpc = "2.0" /* RPC_VERSION */;
    return data;
  }
  buildNotificationBase(method, params) {
    const data = {};
    data.method = method;
    if (params) {
      data.params = params;
    }
    return data;
  }
  // success response
  buildRpcSuccessResponse(id2, result) {
    const data = this.buildRpcSuccessResponseBase(id2, result);
    data.jsonrpc = "2.0" /* RPC_VERSION */;
    return data;
  }
  buildRpcSuccessResponseBase(id2, result) {
    const data = {};
    data.id = id2;
    data.result = result;
    return data;
  }
  // error response
  buildRpcErrorResponse(id2, error) {
    const data = this.buildRpcErrorResponseBase(id2, error);
    data.jsonrpc = "2.0" /* RPC_VERSION */;
    return data;
  }
  buildRpcErrorResponseBase(id2, error) {
    const data = {};
    data.id = id2;
    data.error = error;
    return data;
  }
  idFn() {
    return id(12);
  }
  // tests
  isNotification(data) {
    return !data.id;
  }
  isRequest(data) {
    return data.method;
  }
  isSuccessResponse(data) {
    return data.hasOwnProperty("result");
  }
  isErrorResponse(data) {
    return data.hasOwnProperty("error");
  }
  isRpcError(data) {
    return typeof (data == null ? void 0 : data.code) !== "undefined";
  }
};

// src/utils/wait.ts
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var wait_default = wait;

// src/utils/apiKey.ts
function getApiKey(apiKey) {
  var _a5;
  apiKey = apiKey || ((_a5 = process == null ? void 0 : process.env) == null ? void 0 : _a5.E2B_API_KEY);
  if (!apiKey) {
    throw new AuthenticationError(
      "API key is required, please visit https://e2b.dev/docs to get your API key. You can either set the environment variable `E2B_API_KEY` or you can pass it directly to the sandbox like Sandbox.create({apiKey: 'e2b_...'})"
    );
  }
  return apiKey;
}

// src/sandbox/sandboxConnection.ts
var SandboxConnection = class {
  // let's keep opts readonly, but public - for convenience, mainly when debugging
  constructor(opts) {
    this.opts = opts;
    this.isOpen = false;
    this.rpc = new RpcWebSocketClient();
    this.subscribers = [];
    var _a5, _b, _c;
    this.sandbox = opts.__sandbox;
    this.apiKey = getApiKey(opts.apiKey);
    this.client = new APIClient({ domain: opts.domain });
    this.cwd = opts.cwd;
    if (this.cwd && this.cwd.startsWith("~")) {
      this.cwd = this.cwd.replace("~", "/home/user");
    }
    const defaultEnvVars = { PYTHONUNBUFFERED: "1" };
    this.envVars = __spreadValues(__spreadValues({}, defaultEnvVars), opts.envVars || {});
    this.logger = (_a5 = opts.logger) != null ? _a5 : {
      // by default, we log to the console
      // we don't log debug messages by default
      info: console.info,
      warn: console.warn,
      error: console.error
    };
    (_c = (_b = this.logger).debug) == null ? void 0 : _c.call(_b, `Sandbox "${this.templateID}" initialized`);
  }
  /**
   * ID of the sandbox.
   * 
   * You can use this ID to reconnect to the sandbox later.
   */
  get id() {
    var _a5, _b;
    return `${(_a5 = this.sandbox) == null ? void 0 : _a5.sandboxID}-${(_b = this.sandbox) == null ? void 0 : _b.clientID}`;
  }
  get templateID() {
    return this.opts.template || this.opts.id || "base";
  }
  get refreshSandbox() {
    return withAPIKey(
      this.client.api.path("/sandboxes/{sandboxID}/refreshes").method("post").create()
    );
  }
  get createSandbox() {
    return withAPIKey(
      this.client.api.path("/sandboxes").method("post").create()
    );
  }
  /**
   * List all running sandboxes
   * 
   * @param apiKey API key to use for authentication. If not provided, the `E2B_API_KEY` environment variable will be used.
   * @param domain Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.
   */
  static list(apiKey, domain) {
    return __async(this, null, function* () {
      apiKey = getApiKey(apiKey);
      const client = new APIClient({ domain });
      const listSandboxes = withAPIKey(
        client.api.path("/sandboxes").method("get").create()
      );
      try {
        const res = yield listSandboxes(apiKey, {});
        return res.data.map((sandbox) => __spreadProps(__spreadValues(__spreadValues({
          sandboxID: `${sandbox.sandboxID}-${sandbox.clientID}`,
          templateID: sandbox.templateID,
          cpuCount: sandbox.cpuCount,
          memoryMB: sandbox.memoryMB
        }, sandbox.alias && { alias: sandbox.alias }), sandbox.metadata && { metadata: sandbox.metadata }), {
          startedAt: new Date(sandbox.startedAt)
        }));
      } catch (e) {
        if (e instanceof listSandboxes.Error) {
          const error = e.getActualType();
          if (error.status === 401) {
            throw new Error(
              `Error listing sandboxes - (${error.status}) unauthenticated: ${error.data.message}`
            );
          }
          if (error.status === 500) {
            throw new Error(
              `Error listing sandboxes - (${error.status}) server error: ${error.data.message}`
            );
          }
        }
        throw e;
      }
    });
  }
  /**
   * List all running sandboxes
   * @param sandboxID ID of the sandbox to kill
   * @param apiKey API key to use for authentication. If not provided, the `E2B_API_KEY` environment variable will be used.
   * @param domain Domain to use for the API requests. If not provided, the `E2B_DOMAIN` environment variable will be used.
   */
  static kill(sandboxID, apiKey, domain) {
    return __async(this, null, function* () {
      apiKey = getApiKey(apiKey);
      const shortID = sandboxID.split("-")[0];
      const client = new APIClient({ domain });
      const killSandbox = withAPIKey(
        client.api.path("/sandboxes/{sandboxID}").method("delete").create()
      );
      try {
        yield killSandbox(apiKey, { sandboxID: shortID });
      } catch (e) {
        if (e instanceof killSandbox.Error) {
          const error = e.getActualType();
          if (error.status === 401) {
            throw new Error(
              `Error killing sandbox (${sandboxID}) - (${error.status}) unauthenticated: ${error.data.message}`
            );
          }
          if (error.status === 500) {
            throw new Error(
              `Error killing sandbox (${sandboxID}) - (${error.status}) server error: ${error.data.message}`
            );
          }
        }
        throw e;
      }
    });
  }
  /**
   * Keep the sandbox alive for the specified duration.
   *
   * `keepAlive` method requires `this` context - you may need to bind it.
   * @param duration Duration in milliseconds. Must be between 0 and 3600000 milliseconds
   * @returns Promise that resolves when the sandbox is kept alive
   */
  keepAlive(duration) {
    return __async(this, null, function* () {
      var _a5;
      duration = Math.round(duration / 1e3);
      if (duration < 0 || duration > 3600) {
        throw new Error("Duration must be between 0 and 3600 seconds");
      }
      if (!this.sandbox) {
        throw new Error("Cannot keep alive - sandbox is not initialized");
      }
      yield this.refreshSandbox(this.apiKey, {
        sandboxID: (_a5 = this.sandbox) == null ? void 0 : _a5.sandboxID,
        duration
      });
    });
  }
  /**
   * Get the hostname for the sandbox or for the specified sandbox's port.
   *
   * `getHostname` method requires `this` context - you may need to bind it.
   *
   * @param port Specify if you want to connect to a specific port of the sandbox
   * @returns Hostname of the sandbox or sandbox's port
   */
  getHostname(port) {
    if (this.opts.__debug_hostname) {
      if (port && this.opts.__debug_devEnv === "remote") {
        return `${port}-${this.opts.__debug_hostname}`;
      } else if (port) {
        return `${this.opts.__debug_hostname}:${port}`;
      } else {
        return this.opts.__debug_hostname;
      }
    }
    if (!this.sandbox) {
      throw new Error("Cannot get sandbox's hostname - sandbox is not initialized");
    }
    const hostname = `${this.id}.${this.client.domain}`;
    if (port) {
      return `${port}-${hostname}`;
    } else {
      return hostname;
    }
  }
  /**
   * The function decides whether to use the secure or insecure protocol.
   * @param baseProtocol Specify the specific protocol you want to use. Do not include the `s` in `https` or `wss`.
   * @param secure Specify if you want to use the secure protocol
   * @returns Protocol for the connection to the sandbox
   */
  getProtocol(baseProtocol = "http", secure = this.client.secure) {
    return secure ? `${baseProtocol}s` : baseProtocol;
  }
  /**
   * Close the connection to the sandbox
   *
   * `close` method requires `this` context - you may need to bind it.
   */
  close() {
    return __async(this, null, function* () {
      var _a5, _b, _c, _d, _e, _f, _g, _h;
      if (this.isOpen) {
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, `Closing sandbox "${this.id}"`);
        this.isOpen = false;
        (_d = (_c = this.rpc.ws) == null ? void 0 : _c.terminate) == null ? void 0 : _d.call(_c);
        (_f = (_e = this.rpc.ws) == null ? void 0 : _e.close) == null ? void 0 : _f.call(_e);
        this.subscribers = [];
        (_h = (_g = this.logger).debug) == null ? void 0 : _h.call(_g, "Disconnected from the sandbox");
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _call(service, method, params, opts) {
    return __async(this, null, function* () {
      var _a5, _b;
      (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, `Calling "${service}_${method}" with params:`, params);
      const call = (method2, params2) => __async(this, null, function* () {
        return yield this.rpc.call(method2, params2);
      });
      return yield withTimeout(call, opts == null ? void 0 : opts.timeout)(
        `${service}_${method}`,
        params
      );
    });
  }
  _handleSubscriptions(...subs) {
    return __async(this, null, function* () {
      const results = yield Promise.allSettled(subs);
      if (results.every((r) => r.status === "fulfilled")) {
        return results.map(
          (r) => r.status === "fulfilled" ? r.value : void 0
        );
      }
      yield Promise.all(
        results.filter(assertFulfilled).map((r) => r.value ? this._unsubscribe(r.value) : void 0)
      );
      throw new Error(formatSettledErrors(results));
    });
  }
  // eslint-disable-next-line @typescript-eslint/member-ordering
  _unsubscribe(subID) {
    return __async(this, null, function* () {
      var _a5, _b;
      const subscription = this.subscribers.find((s) => s.subID === subID);
      if (!subscription)
        return;
      yield this._call(subscription.service, "unsubscribe", [subscription.subID]);
      this.subscribers = this.subscribers.filter((s) => s !== subscription);
      (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(
        _a5,
        `Unsubscribed '${subID}' from '${subscription.service}'`
      );
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/member-ordering
  _subscribe(service, handler, method, ...params) {
    return __async(this, null, function* () {
      var _a5, _b;
      const subID = yield this._call(service, "subscribe", [method, ...params]);
      if (typeof subID !== "string") {
        throw new Error(
          `Cannot subscribe to ${service}_${method}${params.length > 0 ? " with params [" + params.join(", ") + "]" : ""}. Expected response should have been a subscription ID, instead we got ${JSON.stringify(
            subID
          )}`
        );
      }
      this.subscribers.push({
        handler,
        service,
        subID
      });
      (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(
        _a5,
        `Subscribed to "${service}_${method}"${params.length > 0 ? " with params [" + params.join(", ") + "] and" : ""} with id "${subID}"`
      );
      return subID;
    });
  }
  /**
   * Open a connection to a new sandbox
   *
   * `open` method requires `this` context - you may need to bind it.
   * @param opts Call options
   * @param {timeout} [opts.timeout] Timeout for sandbox to open in milliseconds (default is 60 seconds)
   */
  _open(opts) {
    return __async(this, null, function* () {
      const open = () => __async(this, null, function* () {
        var _a5, _b, _c, _d;
        if (this.isOpen) {
          throw new Error("Sandbox connect was already called");
        } else {
          this.isOpen = true;
        }
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, "Opening sandbox...");
        if (!this.sandbox && !this.opts.__debug_hostname) {
          try {
            const res = yield this.createSandbox(this.apiKey, {
              templateID: this.templateID,
              metadata: this.opts.metadata
            });
            this.sandbox = res.data;
            (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(_c, `Acquired sandbox "${this.id}"`);
          } catch (e) {
            if (e instanceof this.createSandbox.Error) {
              const error = e.getActualType();
              if (error.status === 400) {
                throw new Error(
                  `Error creating sandbox - (${error.status}) bad request: ${error.data.message}`
                );
              }
              if (error.status === 401) {
                throw new Error(
                  `Error creating sandbox - (${error.status}) unauthenticated: ${error.data.message}`
                );
              }
              if (error.status === 500) {
                throw new Error(
                  `Error creating sandbox - (${error.status}) server error: ${error.data.message}`
                );
              }
            }
            throw e;
          }
        }
        if (this.sandbox && !this.opts.__debug_hostname) {
          this.refresh(this.sandbox.sandboxID);
        }
        yield this.connectRpc();
        return this;
      });
      try {
        return yield withTimeout(open, opts == null ? void 0 : opts.timeout)();
      } catch (err) {
        yield this.close();
        throw err;
      }
    });
  }
  connectRpc() {
    return __async(this, null, function* () {
      const hostname = this.getHostname(this.opts.__debug_port || ENVD_PORT);
      const protocol = this.getProtocol("ws", this.opts.__debug_devEnv !== "local");
      const sandboxURL = `${protocol}://${hostname}${WS_ROUTE}`;
      let isFinished = false;
      let resolveOpening;
      let rejectOpening;
      const openingPromise = new Promise((resolve, reject) => {
        resolveOpening = () => {
          if (isFinished)
            return;
          isFinished = true;
          resolve();
        };
        rejectOpening = () => {
          if (isFinished)
            return;
          isFinished = true;
          reject();
        };
      });
      this.rpc.onOpen(() => {
        var _a5, _b;
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(
          _a5,
          `Connected to sandbox "${this.id}"`
        );
        resolveOpening == null ? void 0 : resolveOpening();
      });
      this.rpc.onError((err) => __async(this, null, function* () {
        var _a5, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(
          _c,
          `Error in WebSocket of sandbox "${this.id}": ${(_b = (_a5 = err.message) != null ? _a5 : err.code) != null ? _b : err.toString()}. Trying to reconnect...`
        );
        if (this.isOpen) {
          yield wait_default(WS_RECONNECT_INTERVAL);
          (_f = (_e = this.logger).debug) == null ? void 0 : _f.call(
            _e,
            `Reconnecting to sandbox "${this.id}"`
          );
          try {
            this.subscribers = [];
            yield this.rpc.connect(sandboxURL);
            (_h = (_g = this.logger).debug) == null ? void 0 : _h.call(
              _g,
              `Reconnected to sandbox "${this.id}"`
            );
          } catch (err2) {
            (_l = (_k = this.logger).debug) == null ? void 0 : _l.call(
              _k,
              `Failed reconnecting to sandbox "${this.id}": ${(_j = (_i = err2.message) != null ? _i : err2.code) != null ? _j : err2.toString()}`
            );
          }
        } else {
          rejectOpening == null ? void 0 : rejectOpening();
        }
      }));
      this.rpc.onClose(() => __async(this, null, function* () {
        var _a5, _b;
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(
          _a5,
          `WebSocket connection to sandbox "${this.id}" closed`
        );
      }));
      this.rpc.onNotification.push(this.handleNotification.bind(this));
      (() => __async(this, null, function* () {
        var _a5, _b, _c, _d, _e, _f;
        try {
          (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(
            _a5,
            `Connecting to sandbox "${this.id}"`
          );
          yield this.rpc.connect(sandboxURL);
        } catch (err) {
          (_f = (_e = this.logger).debug) == null ? void 0 : _f.call(
            _e,
            `Error connecting to sandbox "${this.id}": ${(_d = (_c = err.message) != null ? _c : err.code) != null ? _d : err.toString()}`
          );
        }
      }))();
      yield openingPromise;
    });
  }
  handleNotification(data) {
    var _a5, _b;
    (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, "Handling notification:", data);
    this.subscribers.filter((s) => {
      var _a6;
      return s.subID === ((_a6 = data.params) == null ? void 0 : _a6.subscription);
    }).forEach((s) => {
      var _a6;
      return s.handler((_a6 = data.params) == null ? void 0 : _a6.result);
    });
  }
  refresh(sandboxID) {
    return __async(this, null, function* () {
      var _a5, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, `Started refreshing sandbox "${sandboxID}"`);
      try {
        while (true) {
          if (!this.isOpen) {
            (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(
              _c,
              `Cannot refresh sandbox ${this.id} - it was closed`
            );
            return;
          }
          yield wait_default(SANDBOX_REFRESH_PERIOD);
          try {
            yield this.refreshSandbox(this.apiKey, {
              sandboxID,
              duration: 0
            });
            (_f = (_e = this.logger).debug) == null ? void 0 : _f.call(_e, `Refreshed sandbox "${sandboxID}"`);
          } catch (e) {
            if (e instanceof this.refreshSandbox.Error) {
              const error = e.getActualType();
              if (error.status === 404) {
                (_h = (_g = this.logger).warn) == null ? void 0 : _h.call(
                  _g,
                  `Error refreshing sandbox - (${error.status}): ${error.data.message}`
                );
                return;
              }
              (_j = (_i = this.logger).warn) == null ? void 0 : _j.call(
                _i,
                `Refreshing sandbox "${sandboxID}" failed - (${error.status})`
              );
            }
          }
        }
      } finally {
        (_l = (_k = this.logger).debug) == null ? void 0 : _l.call(_k, `Stopped refreshing sandbox "${sandboxID}"`);
        yield this.close();
      }
    });
  }
};

// src/utils/filesystem.ts
var import_path_browserify = __toESM(require("path-browserify"));
var resolvePath = (inputPath, cwd, logger) => {
  var _a5, _b, _c;
  let result;
  if (inputPath.startsWith("./")) {
    result = import_path_browserify.default.posix.join(cwd || "/home/user", inputPath);
    if (!cwd) {
      (_a5 = logger.warn) == null ? void 0 : _a5.call(
        logger,
        `Path starts with './' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`
      );
    }
    return result;
  }
  if (inputPath.startsWith("../")) {
    result = import_path_browserify.default.posix.join(cwd || "/home/user", inputPath);
    if (!cwd) {
      (_b = logger.warn) == null ? void 0 : _b.call(
        logger,
        `Path starts with '../' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`
      );
    }
    return result;
  }
  if (inputPath.startsWith("~/")) {
    result = import_path_browserify.default.posix.join(cwd || "/home/user", inputPath.substring(2));
    if (!cwd) {
      (_c = logger.warn) == null ? void 0 : _c.call(
        logger,
        `Path starts with '~/' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`
      );
    }
    return result;
  }
  if (!inputPath.startsWith("/") && cwd) {
    return import_path_browserify.default.posix.join(cwd, inputPath);
  }
  return inputPath;
};

// src/templates/openai.ts
var Actions = class {
  constructor(sandbox) {
    this.sandbox = sandbox;
  }
  /**
   * Call the required actions for the provided run and return their outputs.
   * 
   * @param run OpenAI run object from `openai.beta.threads.runs.retrieve` or `openai.beta.threads.runs.retrieve.create` call that contains the names of the required actions and their arguments.
   * @returns The outputs of the required actions in the run.
   */
  run(run) {
    return __async(this, null, function* () {
      if (run.status !== "requires_action") {
        return [];
      }
      if (!run.required_action) {
        return [];
      }
      const outputs = [];
      for (const toolCall of run.required_action.submit_tool_outputs.tool_calls) {
        const action = this.sandbox._actions.get(toolCall.function.name);
        if (!action) {
          console.warn(`Action ${toolCall.function.name} not found`);
          continue;
        }
        const args = JSON.parse(toolCall.function.arguments);
        const output = yield action(this.sandbox, args);
        outputs.push({
          tool_call_id: toolCall.id,
          output
        });
      }
      return outputs;
    });
  }
};

// src/sandbox/index.ts
var Sandbox = class extends SandboxConnection {
  /**
   * Use `Sandbox.create()` instead.
   *
   * @hidden
   * @hide
   * @internal
   * @access protected
   */
  constructor(opts) {
    opts = opts || {};
    super(opts);
    // We use any here because we cannot properly reference the type of the Sandbox subclass
    this._actions = /* @__PURE__ */ new Map();
    this.onScanPorts = opts.onScanPorts;
    this.filesystem = {
      list: (path2, opts2) => __async(this, null, function* () {
        return yield this._call(
          filesystemService,
          "list",
          [_resolvePath(path2)],
          opts2
        );
      }),
      read: (path2, opts2) => __async(this, null, function* () {
        return yield this._call(
          filesystemService,
          "read",
          [_resolvePath(path2)],
          opts2
        );
      }),
      remove: (path2, opts2) => __async(this, null, function* () {
        yield this._call(
          filesystemService,
          "remove",
          [_resolvePath(path2)],
          opts2
        );
      }),
      write: (path2, content, opts2) => __async(this, null, function* () {
        yield this._call(
          filesystemService,
          "write",
          [_resolvePath(path2), content],
          opts2
        );
      }),
      writeBytes: (path2, content) => __async(this, null, function* () {
        const base64Content = Buffer.from(content).toString("base64");
        yield this._call(filesystemService, "writeBase64", [
          _resolvePath(path2),
          base64Content
        ]);
      }),
      readBytes: (path2) => __async(this, null, function* () {
        const base64Content = yield this._call(
          filesystemService,
          "readBase64",
          [_resolvePath(path2)]
        );
        return Buffer.from(base64Content, "base64");
      }),
      makeDir: (path2, opts2) => __async(this, null, function* () {
        yield this._call(
          filesystemService,
          "makeDir",
          [_resolvePath(path2)],
          opts2
        );
      }),
      watchDir: (path2) => {
        var _a5, _b;
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, `Watching directory "${path2}"`);
        const npath = (0, import_normalize_path.default)(_resolvePath(path2));
        return new filesystemWatcher_default(this, npath);
      }
    };
    this.terminal = {
      start: (_0) => __async(this, [_0], function* ({
        onData,
        size,
        onExit,
        envVars,
        cmd,
        cwd = "",
        terminalID = id(12),
        timeout = void 0
      }) {
        const start = (_02) => __async(this, [_02], function* ({
          onData: onData2,
          size: size2,
          onExit: onExit2,
          envVars: envVars2,
          cmd: cmd2,
          cwd: cwd2 = "",
          rootDir,
          terminalID: terminalID2 = id(12)
        }) {
          var _a5, _b, _c, _d;
          (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, `Starting terminal "${terminalID2}"`);
          if (!cwd2 && rootDir) {
            (_d = (_c = this.logger).warn) == null ? void 0 : _d.call(
              _c,
              "The rootDir parameter is deprecated, use cwd instead."
            );
            cwd2 = rootDir;
          }
          if (!cwd2 && this.cwd) {
            cwd2 = this.cwd;
          }
          envVars2 = envVars2 || {};
          envVars2 = __spreadValues(__spreadValues({}, this.envVars), envVars2);
          const { promise: terminalExited, resolve: triggerExit } = createDeferredPromise();
          const output = new TerminalOutput();
          function handleData(data) {
            output.addData(data);
            onData2 == null ? void 0 : onData2(data);
          }
          const [onDataSubID, onExitSubID] = yield this._handleSubscriptions(
            this._subscribe(terminalService, handleData, "onData", terminalID2),
            this._subscribe(terminalService, triggerExit, "onExit", terminalID2)
          );
          const { promise: unsubscribing, resolve: handleFinishUnsubscribing } = createDeferredPromise();
          terminalExited.then(() => __async(this, null, function* () {
            var _a6, _b2;
            Promise.allSettled([
              this._unsubscribe(onExitSubID),
              this._unsubscribe(onDataSubID)
            ]).then((results) => {
              var _a7, _b3;
              const errMsg = formatSettledErrors(results);
              if (errMsg) {
                (_b3 = (_a7 = this.logger).debug) == null ? void 0 : _b3.call(_a7, errMsg);
              }
            });
            (_b2 = (_a6 = this.logger).debug) == null ? void 0 : _b2.call(_a6, `Terminal "${terminalID2}" exited`);
            onExit2 == null ? void 0 : onExit2();
            handleFinishUnsubscribing(output);
          }));
          try {
            yield this._call(terminalService, "start", [
              terminalID2,
              size2.cols,
              size2.rows,
              // Handle optional args for old devbookd compatibility
              ...cmd2 !== void 0 ? [envVars2, cmd2, cwd2] : []
            ]);
          } catch (err) {
            triggerExit();
            yield unsubscribing;
            throw err;
          }
          return new Terminal(
            terminalID2,
            this,
            triggerExit,
            unsubscribing,
            output
          );
        });
        return yield withTimeout(
          start,
          timeout
        )({
          onData,
          size,
          onExit,
          envVars,
          cmd,
          cwd,
          terminalID
        });
      })
    };
    this.process = {
      start: (optsOrCmd) => __async(this, null, function* () {
        const opts2 = typeof optsOrCmd === "string" ? { cmd: optsOrCmd } : optsOrCmd;
        const start = (_0) => __async(this, [_0], function* ({
          cmd,
          onStdout,
          onStderr,
          onExit,
          envVars = {},
          cwd = "",
          rootDir,
          processID = id(12)
        }) {
          var _a5, _b, _c, _d;
          if (!cwd && rootDir) {
            (_b = (_a5 = this.logger).warn) == null ? void 0 : _b.call(
              _a5,
              "The rootDir parameter is deprecated, use cwd instead."
            );
            cwd = rootDir;
          }
          if (!cwd && this.cwd) {
            cwd = this.cwd;
          }
          if (!cmd)
            throw new Error("cmd is required");
          envVars = envVars || {};
          envVars = __spreadValues(__spreadValues({}, this.envVars), envVars);
          (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(_c, `Starting process "${processID}", cmd: "${cmd}"`);
          const { promise: processExited, resolve: triggerExit } = createDeferredPromise();
          const output = new ProcessOutput();
          const handleExit = (exitCode) => {
            output.setExitCode(exitCode);
            triggerExit();
          };
          const handleStdout = (data) => {
            const message = new ProcessMessage(
              data.line,
              data.timestamp,
              false
            );
            output.addStdout(message);
            if (onStdout) {
              onStdout(message);
            } else if (this.opts.onStdout) {
              this.opts.onStdout(message);
            }
          };
          const handleStderr = (data) => {
            const message = new ProcessMessage(data.line, data.timestamp, true);
            output.addStderr(message);
            if (onStderr) {
              onStderr(message);
            } else if (this.opts.onStderr) {
              this.opts.onStderr(message);
            }
          };
          const [onExitSubID, onStdoutSubID, onStderrSubID] = yield this._handleSubscriptions(
            this._subscribe(processService, handleExit, "onExit", processID),
            this._subscribe(
              processService,
              handleStdout,
              "onStdout",
              processID
            ),
            this._subscribe(
              processService,
              handleStderr,
              "onStderr",
              processID
            )
          );
          const { promise: unsubscribing, resolve: handleFinishUnsubscribing } = createDeferredPromise();
          processExited.then(() => __async(this, null, function* () {
            var _a6, _b2;
            Promise.allSettled([
              this._unsubscribe(onExitSubID),
              onStdoutSubID ? this._unsubscribe(onStdoutSubID) : void 0,
              onStderrSubID ? this._unsubscribe(onStderrSubID) : void 0
            ]).then((results) => {
              var _a7, _b3;
              const errMsg = formatSettledErrors(results);
              if (errMsg) {
                (_b3 = (_a7 = this.logger).debug) == null ? void 0 : _b3.call(_a7, errMsg);
              }
            });
            (_b2 = (_a6 = this.logger).debug) == null ? void 0 : _b2.call(_a6, `Process "${processID}" exited`);
            if (onExit) {
              onExit(output.exitCode || 0);
            } else if (this.opts.onExit) {
              this.opts.onExit();
            }
            handleFinishUnsubscribing(output);
          }));
          try {
            yield this._call(processService, "start", [
              processID,
              cmd,
              envVars,
              cwd
            ]);
          } catch (err) {
            triggerExit();
            yield unsubscribing;
            if (/error starting process '\w+': fork\/exec \/bin\/bash: no such file or directory/.test(err == null ? void 0 : err.message)) {
              throw new CurrentWorkingDirectoryDoesntExistError(
                `Failed to start the process. You are trying set 'cwd' to a directory that does not exist.
${err == null ? void 0 : err.message}`
              );
            }
            throw err;
          }
          return new Process(
            processID,
            this,
            triggerExit,
            unsubscribing,
            output
          );
        });
        const timeout = opts2.timeout;
        return yield withTimeout(start, timeout)(opts2);
      }),
      startAndWait: (optsOrCmd) => __async(this, null, function* () {
        const opts2 = typeof optsOrCmd === "string" ? { cmd: optsOrCmd } : optsOrCmd;
        const process2 = yield this.process.start(opts2);
        const out = yield process2.wait();
        return out;
      })
    };
    const _resolvePath = (path2) => resolvePath(path2, this.cwd, this.logger);
  }
  /**
   * URL that can be used to download or upload file to the sandbox via a multipart/form-data POST request.
   * This is useful if you're uploading files directly from the browser.
   * The file will be uploaded to the user's home directory with the same name.
   * If a file with the same name already exists, it will be overwritten.
   */
  get fileURL() {
    const protocol = this.getProtocol("http", this.opts.__debug_devEnv !== "local");
    const hostname = this.getHostname(this.opts.__debug_port || ENVD_PORT);
    return `${protocol}://${hostname}${FILE_ROUTE}`;
  }
  /**
   * Returns a map of added actions.
   *
   * @returns Map of added actions
   */
  get actions() {
    return new Map(this._actions);
  }
  /**
   * OpenAI integration that can be used to get output for the actions added in the sandbox.
   *
   * @returns OpenAI integration
   */
  get openai() {
    return {
      actions: new Actions(this)
    };
  }
  static create(optsOrTemplate) {
    return __async(this, null, function* () {
      const opts = typeof optsOrTemplate === "string" ? { template: optsOrTemplate } : optsOrTemplate;
      const sandbox = new this(opts);
      yield sandbox._open({ timeout: opts == null ? void 0 : opts.timeout });
      return sandbox;
    });
  }
  static reconnect(sandboxIDorOpts) {
    return __async(this, null, function* () {
      let id2;
      let opts;
      if (typeof sandboxIDorOpts === "string") {
        id2 = sandboxIDorOpts;
        opts = {};
      } else {
        id2 = sandboxIDorOpts.sandboxID;
        opts = sandboxIDorOpts;
      }
      const sandboxIDAndClientID = id2.split("-");
      const sandboxID = sandboxIDAndClientID[0];
      const clientID = sandboxIDAndClientID[1];
      opts.__sandbox = { sandboxID, clientID, templateID: "unknown" };
      const sandbox = new this(opts);
      yield sandbox._open({ timeout: opts == null ? void 0 : opts.timeout });
      return sandbox;
    });
  }
  addAction(actionOrName, action) {
    if (typeof actionOrName === "string") {
      if (!action)
        throw new Error("Action is required");
      this._actions.set(actionOrName, action);
      return this;
    } else if (typeof actionOrName === "function") {
      action = actionOrName;
      if (!action.name) {
        throw new Error("Action name is required");
      }
      this._actions.set(action.name, action);
    } else {
      throw new Error("Action or action name and action is required");
    }
    return this;
  }
  /**
   * Remove an action.
   * @param name Action name
   * @returns Sandbox
   *
   * @example
   * ```ts
   * const sandbox = await Sandbox.create()
   * sandbox.addAction('hello', (sandbox, args) => 'Hello World')
   * sandbox.removeAction('hello')
   * ```
   */
  removeAction(name) {
    this._actions.delete(name);
    return this;
  }
  /**
   * Uploads a file to the sandbox.
   * The file will be uploaded to the user's home directory with the same name.
   * If a file with the same name already exists, it will be overwritten.
   *
   * **You can use the {@link Sandbox.fileURL} property and upload file directly via POST multipart/form-data**
   *
   */
  uploadFile(file, filename) {
    return __async(this, null, function* () {
      const body = new FormData();
      const blob = file instanceof Blob ? file : new Blob([file], { type: "application/octet-stream" });
      body.append("file", blob, filename);
      const response = yield fetch(this.fileURL, {
        method: "POST",
        body
      });
      if (!response.ok) {
        const text = yield response.text();
        throw new Error(
          `Failed to upload file ${response.status} - ${response.statusText}: ${text}`
        );
      }
      return `/home/user/${filename}`;
    });
  }
  /**
   * Downloads a file from the sandbox.
   * @param remotePath Path to a file on the sandbox
   * @param format Format of the downloaded file
   * @returns File content
   *
   * @example
   * ```ts
   * const sandbox = await Sandbox.create()
   * const content = await sandbox.downloadFile('/home/user/file.txt')
   * ```
   */
  downloadFile(remotePath, format) {
    return __async(this, null, function* () {
      remotePath = encodeURIComponent(remotePath);
      const response = yield fetch(`${this.fileURL}?path=${remotePath}`);
      if (!response.ok) {
        const text = yield response.text();
        throw new Error(`Failed to download file '${remotePath}': ${text}`);
      }
      switch (format) {
        case "base64":
          return Buffer.from(yield response.arrayBuffer()).toString("base64");
        case "blob":
          return yield response.blob();
        case "buffer":
          return Buffer.from(yield response.arrayBuffer());
        case "arraybuffer":
          return yield response.arrayBuffer();
        case "text":
          return yield response.text();
        default:
          return yield response.arrayBuffer();
      }
    });
  }
  _open(opts) {
    return __async(this, null, function* () {
      var _a5, _b;
      yield __superGet(Sandbox.prototype, this, "_open").call(this, opts);
      const portsHandler = this.onScanPorts ? (ports) => {
        var _a6;
        return (_a6 = this.onScanPorts) == null ? void 0 : _a6.call(
          this,
          ports.map((p) => ({ ip: p.Ip, port: p.Port, state: p.State }))
        );
      } : void 0;
      yield this._handleSubscriptions(
        portsHandler ? this._subscribe(codeSnippetService, portsHandler, "scanOpenedPorts") : void 0
      );
      if (this.cwd) {
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, `Custom cwd for Sandbox set: "${this.cwd}"`);
        yield this.filesystem.makeDir(this.cwd);
      }
      if (this.opts.onStdout || this.opts.onStderr) {
        this.handleStartCmdLogs();
      }
      return this;
    });
  }
  handleStartCmdLogs() {
    return __async(this, null, function* () {
      var _a5, _b;
      try {
        yield this.process.startAndWait({
          cmd: "sudo journalctl --follow --lines=all -o cat _SYSTEMD_UNIT=start_cmd.service",
          envVars: {},
          cwd: "/"
        });
      } catch (err) {
        (_b = (_a5 = this.logger).debug) == null ? void 0 : _b.call(_a5, "start command not started", err);
      }
    });
  }
};

// src/runCode.ts
var CodeRuntime = /* @__PURE__ */ ((CodeRuntime2) => {
  CodeRuntime2["Node16"] = "Node16";
  CodeRuntime2["Python3"] = "Python3";
  CodeRuntime2["Bash"] = "Bash";
  CodeRuntime2["Python3_DataAnalysis"] = "Python3-DataAnalysis";
  return CodeRuntime2;
})(CodeRuntime || {});
function runCode(runtime, code, opts) {
  return __async(this, null, function* () {
    var _a5;
    let binary = "";
    let filepath = "";
    let envID = "";
    switch (runtime) {
      case "Node16" /* Node16 */:
        envID = "base";
        binary = "node";
        filepath = "/index.js";
        break;
      case "Python3" /* Python3 */:
        envID = "base";
        binary = "python3";
        filepath = "/main.py";
        break;
      case "Python3-DataAnalysis" /* Python3_DataAnalysis */:
        envID = "Python3-DataAnalysis";
        binary = "python3";
        filepath = "/main.py";
        break;
      case "Bash" /* Bash */:
        envID = "base";
        binary = "bash";
        filepath = "/main.sh";
        break;
      default:
        throw new Error(
          `The "${runtime}" runtime isn't supported. Please contact us (hello@e2b.dev) if you need support for this runtime`
        );
    }
    const sandbox = yield Sandbox.create({
      template: envID,
      apiKey: (opts == null ? void 0 : opts.apiKey) || ((_a5 = process == null ? void 0 : process.env) == null ? void 0 : _a5.E2B_API_KEY) || ""
      // Sandbox.create will throw an error if the API key is not provided so no need to check here
    });
    yield sandbox.filesystem.write(filepath, code);
    const out = yield sandbox.process.startAndWait(`${binary} ${filepath}`);
    yield sandbox.close();
    return {
      stdout: out.stdout,
      stderr: out.stderr
    };
  });
}

// src/templates/dataAnalysis.ts
var Artifact = class {
  constructor(path2, sandbox) {
    this.path = path2;
    this._sandbox = sandbox;
  }
  download() {
    return __async(this, null, function* () {
      return this._sandbox.downloadFile(this.path);
    });
  }
};
var _DataAnalysis = class extends Sandbox {
  /**
   * Use `DataAnalysis.create()` instead.
   * 
   * @hidden
   * @hide
   * @internal
   * @access protected
   */
  constructor(opts) {
    super(__spreadValues({ template: opts.template || _DataAnalysis.template }, opts));
  }
  static create(opts) {
    return __async(this, null, function* () {
      const sandbox = new _DataAnalysis(__spreadValues({}, opts ? opts : {}));
      yield sandbox._open({ timeout: opts == null ? void 0 : opts.timeout });
      return sandbox;
    });
  }
  runPython(_0) {
    return __async(this, arguments, function* (code, opts = {}) {
      const artifacts = [];
      const registerArtifacts = (event) => __async(this, null, function* () {
        var _a5;
        if (event.operation === "Create" /* Create */) {
          const artifact = new Artifact(event.path, this);
          artifacts.push(event.path);
          yield (_a5 = opts.onArtifact) == null ? void 0 : _a5.call(opts, artifact);
        }
      });
      const watcher = this.filesystem.watchDir("/home/user/artifacts");
      watcher.addEventListener(registerArtifacts);
      yield watcher.start();
      const currentEpoch = (/* @__PURE__ */ new Date()).getTime();
      const codefilePath = `/tmp/main-${currentEpoch}.py`;
      yield this.filesystem.write(codefilePath, code);
      const output = yield this.process.startAndWait(__spreadValues({
        cmd: `python ${codefilePath}`
      }, opts));
      yield watcher.stop();
      return {
        stdout: output.stdout,
        stderr: output.stderr,
        artifacts: artifacts.map((artifact) => new Artifact(artifact, this))
      };
    });
  }
  installPythonPackages(packageNames) {
    return __async(this, null, function* () {
      yield this.installPackages("pip install", packageNames);
    });
  }
  installSystemPackages(packageNames) {
    return __async(this, null, function* () {
      yield this.installPackages("sudo apt-get install -y", packageNames);
    });
  }
  installPackages(command, packageNames) {
    return __async(this, null, function* () {
      if (Array.isArray(packageNames)) {
        packageNames = packageNames.join(" ");
      }
      packageNames = packageNames.trim();
      if (packageNames.length === 0) {
        return;
      }
      const out = yield this.process.startAndWait(`${command} ${packageNames}`);
      if (out.exitCode !== 0) {
        throw new Error(`Failed to install package ${packageNames}: ${out.stderr}`);
      }
    });
  }
};
var DataAnalysis = _DataAnalysis;
DataAnalysis.template = "Python3-DataAnalysis";

// src/index.ts
var src_default = Sandbox;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APIClient,
  API_HOST,
  Artifact,
  AuthenticationError,
  CodeInterpreter,
  CodeRuntime,
  CurrentWorkingDirectoryDoesntExistError,
  DataAnalysis,
  FilesystemOperation,
  FilesystemWatcher,
  Process,
  ProcessMessage,
  ProcessOutput,
  SANDBOX_DOMAIN,
  Sandbox,
  Terminal,
  TerminalOutput,
  TimeoutError,
  runCode,
  withAPIKey,
  withAccessToken
});
//# sourceMappingURL=index.js.map